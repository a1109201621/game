// ==================== Debugæ—¥å¿—ç³»ç»Ÿ ====================
const DebugLog = {
    errors: [],
    aiLogs: [],
    allLogs: [],

    // è·å–å½“å‰æ—¶é—´æˆ³
    getTimestamp() {
        const now = new Date();
        return now.toLocaleString('zh-CN', {
            hour12: false,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        });
    },

    // æ·»åŠ é”™è¯¯æ—¥å¿—
    error(source, message, details = null) {
        const log = {
            id: Date.now(),
            type: 'error',
            source: source,
            message: message,
            details: details,
            timestamp: this.getTimestamp()
        };
        this.errors.push(log);
        this.allLogs.push(log);
        this.updateBadges();
        this.updateDebugBtn();
        console.error(`[DEBUG ERROR] ${source}: ${message}`, details);
    },

    // æ·»åŠ è­¦å‘Šæ—¥å¿—
    warning(source, message, details = null) {
        const log = {
            id: Date.now(),
            type: 'warning',
            source: source,
            message: message,
            details: details,
            timestamp: this.getTimestamp()
        };
        this.allLogs.push(log);
        this.updateBadges();
        console.warn(`[DEBUG WARNING] ${source}: ${message}`, details);
    },

    // æ·»åŠ ä¿¡æ¯æ—¥å¿—
    info(source, message, details = null) {
        const log = {
            id: Date.now(),
            type: 'info',
            source: source,
            message: message,
            details: details,
            timestamp: this.getTimestamp()
        };
        this.allLogs.push(log);
        this.updateBadges();
        console.log(`[DEBUG INFO] ${source}: ${message}`, details);
    },

    // æ·»åŠ æˆåŠŸæ—¥å¿—
    success(source, message, details = null) {
        const log = {
            id: Date.now(),
            type: 'success',
            source: source,
            message: message,
            details: details,
            timestamp: this.getTimestamp()
        };
        this.allLogs.push(log);
        this.updateBadges();
        console.log(`[DEBUG SUCCESS] ${source}: ${message}`, details);
    },

    // æ·»åŠ AIäº¤äº’æ—¥å¿—
    aiRequest(source, prompt, model) {
        const log = {
            id: Date.now(),
            type: 'request',
            source: source,
            model: model,
            prompt: prompt,
            response: null,
            status: 'pending',
            timestamp: this.getTimestamp(),
            duration: null
        };
        this.aiLogs.push(log);
        this.allLogs.push({
            id: log.id,
            type: 'info',
            source: `AIè¯·æ±‚ - ${source}`,
            message: `å‘é€è¯·æ±‚åˆ° ${model}`,
            details: prompt,
            timestamp: log.timestamp
        });
        this.updateBadges();
        return log.id;
    },

    // æ›´æ–°AIå“åº”
    aiResponse(logId, response, success = true, error = null) {
        const log = this.aiLogs.find(l => l.id === logId);
        if (log) {
            log.response = response;
            log.status = success ? 'success' : 'error';
            log.error = error;
            log.duration = Date.now() - log.id;

            this.allLogs.push({
                id: Date.now(),
                type: success ? 'success' : 'error',
                source: `AIå“åº” - ${log.source}`,
                message: success ? `æ”¶åˆ°å“åº” (${log.duration}ms)` : `è¯·æ±‚å¤±è´¥: ${error}`,
                details: response,
                timestamp: this.getTimestamp()
            });

            if (!success) {
                this.errors.push({
                    id: Date.now(),
                    type: 'error',
                    source: `AIé”™è¯¯ - ${log.source}`,
                    message: error,
                    details: { prompt: log.prompt, response: response },
                    timestamp: this.getTimestamp()
                });
            }
        }
        this.updateBadges();
        this.updateDebugBtn();
    },

    // æ›´æ–°å¾½ç« æ•°å­—
    updateBadges() {
        const errorBadge = document.getElementById('errorCountBadge');
        const aiBadge = document.getElementById('aiCountBadge');
        const allBadge = document.getElementById('allCountBadge');

        if (errorBadge) errorBadge.textContent = this.errors.length;
        if (aiBadge) aiBadge.textContent = this.aiLogs.length;
        if (allBadge) allBadge.textContent = this.allLogs.length;
    },

    // æ›´æ–°DebugæŒ‰é’®çŠ¶æ€
    updateDebugBtn() {
        const btn = document.getElementById('debugBtn');
        if (btn) {
            if (this.errors.length > 0) {
                btn.classList.add('has-errors');
                btn.innerHTML = `ğŸ› Debug (${this.errors.length})`;
            } else {
                btn.classList.remove('has-errors');
                btn.innerHTML = 'ğŸ› Debug';
            }
        }
    },

    // æ¸²æŸ“é”™è¯¯æ—¥å¿—
    renderErrors() {
        const container = document.getElementById('errorLogContainer');
        if (!container) return;

        if (this.errors.length === 0) {
            container.innerHTML = `
    <div class="debug-empty">
      <div class="debug-empty-icon">âœ…</div>
      <p>æš‚æ— é”™è¯¯è®°å½•</p>
    </div>
  `;
            return;
        }

        container.innerHTML = this.errors.slice().reverse().map(log => `
  <div class="debug-log-item error">
    <div class="debug-log-header">
      <span class="debug-log-type error">âŒ ERROR</span>
      <span class="debug-log-time">${log.timestamp}</span>
    </div>
    <div class="debug-log-source">ğŸ“ ${log.source}</div>
    <div class="debug-log-message">${this.escapeHtml(log.message)}</div>
    ${log.details ? `
      <button class="debug-log-toggle" onclick="DebugLog.toggleDetails(${log.id})">
        å±•å¼€è¯¦æƒ… â–¼
      </button>
      <div class="debug-log-details" id="details-${log.id}" style="display: none;">
${typeof log.details === 'object' ? JSON.stringify(log.details, null, 2) : this.escapeHtml(String(log.details))}
      </div>
    ` : ''}
  </div>
`).join('');
    },

    // æ¸²æŸ“AIæ—¥å¿—
    renderAI() {
        const container = document.getElementById('aiLogContainer');
        if (!container) return;

        if (this.aiLogs.length === 0) {
            container.innerHTML = `
    <div class="debug-empty">
      <div class="debug-empty-icon">ğŸ¤–</div>
      <p>æš‚æ— AIäº¤äº’è®°å½•</p>
    </div>
  `;
            return;
        }

        container.innerHTML = this.aiLogs.slice().reverse().map(log => `
  <div class="ai-log-item">
    <div class="ai-log-header">
      <div class="ai-log-title">${log.source}</div>
      <div class="ai-log-meta">
        <span>ğŸ“¡ ${log.model}</span>
        <span>â±ï¸ ${log.duration ? log.duration + 'ms' : 'è¿›è¡Œä¸­...'}</span>
        <span class="ai-log-status ${log.status}">${log.status === 'pending' ? 'â³ è¯·æ±‚ä¸­' :
                log.status === 'success' ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'
            }</span>
      </div>
    </div>

    <div class="ai-log-section">
      <div class="ai-log-section-title request">ğŸ“¤ å‘é€çš„æç¤ºè¯</div>
      <div class="ai-log-content collapsed" id="prompt-${log.id}">
${this.escapeHtml(log.prompt)}
      </div>
      <button class="debug-log-toggle" onclick="DebugLog.toggleAIContent('prompt-${log.id}')">
        å±•å¼€å®Œæ•´å†…å®¹ â–¼
      </button>
    </div>

    <div class="ai-log-section">
      <div class="ai-log-section-title response">ğŸ“¥ æ”¶åˆ°çš„å“åº”</div>
      <div class="ai-log-content collapsed" id="response-${log.id}">
${log.response ? this.escapeHtml(log.response) : '(ç­‰å¾…å“åº”...)'}
      </div>
      ${log.response ? `
        <button class="debug-log-toggle" onclick="DebugLog.toggleAIContent('response-${log.id}')">
          å±•å¼€å®Œæ•´å†…å®¹ â–¼
        </button>
      ` : ''}
    </div>

    ${log.error ? `
      <div class="ai-log-section">
        <div class="ai-log-section-title" style="color: var(--accent-red);">âš ï¸ é”™è¯¯ä¿¡æ¯</div>
        <div class="ai-log-content" style="border: 1px solid var(--accent-red);">
${this.escapeHtml(log.error)}
        </div>
      </div>
    ` : ''}
  </div>
`).join('');
    },

    // æ¸²æŸ“å…¨éƒ¨æ—¥å¿—
    renderAll() {
        const container = document.getElementById('allLogContainer');
        if (!container) return;

        if (this.allLogs.length === 0) {
            container.innerHTML = `
    <div class="debug-empty">
      <div class="debug-empty-icon">ğŸ“‹</div>
      <p>æš‚æ— æ—¥å¿—è®°å½•</p>
    </div>
  `;
            return;
        }

        container.innerHTML = this.allLogs.slice().reverse().map(log => `
  <div class="debug-log-item ${log.type}">
    <div class="debug-log-header">
      <span class="debug-log-type ${log.type}">${this.getTypeIcon(log.type)} ${log.type.toUpperCase()}</span>
      <span class="debug-log-time">${log.timestamp}</span>
    </div>
    <div class="debug-log-source">ğŸ“ ${log.source}</div>
    <div class="debug-log-message">${this.escapeHtml(log.message)}</div>
    ${log.details ? `
      <button class="debug-log-toggle" onclick="DebugLog.toggleDetails(${log.id})">
        å±•å¼€è¯¦æƒ… â–¼
      </button>
      <div class="debug-log-details" id="details-${log.id}" style="display: none;">
${typeof log.details === 'object' ? JSON.stringify(log.details, null, 2) : this.escapeHtml(String(log.details))}
      </div>
    ` : ''}
  </div>
`).join('');
    },

    // åˆ·æ–°æ¸¸æˆçŠ¶æ€æ˜¾ç¤º
    refreshState() {
        const display = document.getElementById('gameStateDisplay');
        if (display) {
            // åˆ›å»ºä¸€ä¸ªä¸åŒ…å«chatHistoryçš„å‰¯æœ¬ï¼ˆå¤ªé•¿äº†ï¼‰
            const stateCopy = JSON.parse(JSON.stringify(GameState));
            stateCopy.chatHistory = `[${GameState.chatHistory.length} æ¡æ¶ˆæ¯ - å·²çœç•¥]`;
            display.textContent = JSON.stringify(stateCopy, null, 2);
        }
        showNotification('âœ… çŠ¶æ€å·²åˆ·æ–°', 'success');
    },

    // è·å–ç±»å‹å›¾æ ‡
    getTypeIcon(type) {
        const icons = {
            error: 'âŒ',
            warning: 'âš ï¸',
            info: 'â„¹ï¸',
            success: 'âœ…',
            request: 'ğŸ“¤',
            response: 'ğŸ“¥'
        };
        return icons[type] || 'ğŸ“‹';
    },

    // HTMLè½¬ä¹‰
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    },

    // åˆ‡æ¢è¯¦æƒ…æ˜¾ç¤º
    toggleDetails(logId) {
        const details = document.getElementById(`details-${logId}`);
        if (details) {
            const isHidden = details.style.display === 'none';
            details.style.display = isHidden ? 'block' : 'none';
            const btn = details.previousElementSibling;
            if (btn) {
                btn.textContent = isHidden ? 'æ”¶èµ·è¯¦æƒ… â–²' : 'å±•å¼€è¯¦æƒ… â–¼';
            }
        }
    },

    // åˆ‡æ¢AIå†…å®¹æ˜¾ç¤º
    toggleAIContent(elementId) {
        const element = document.getElementById(elementId);
        if (element) {
            const isCollapsed = element.classList.contains('collapsed');
            element.classList.toggle('collapsed');
            const btn = element.nextElementSibling;
            if (btn && btn.classList.contains('debug-log-toggle')) {
                btn.textContent = isCollapsed ? 'æ”¶èµ·å†…å®¹ â–²' : 'å±•å¼€å®Œæ•´å†…å®¹ â–¼';
            }
        }
    },

    // å¯¼å‡ºé”™è¯¯æ—¥å¿—
    exportErrors() {
        this.downloadJSON(this.errors, 'error_logs');
    },

    // å¯¼å‡ºAIæ—¥å¿—
    exportAI() {
        this.downloadJSON(this.aiLogs, 'ai_logs');
    },

    // å¯¼å‡ºå…¨éƒ¨æ—¥å¿—
    exportAll() {
        this.downloadJSON({
            errors: this.errors,
            aiLogs: this.aiLogs,
            allLogs: this.allLogs,
            gameState: GameState
        }, 'all_debug_logs');
    },

    // å¯¼å‡ºæ¸¸æˆçŠ¶æ€
    exportState() {
        this.downloadJSON(GameState, 'game_state');
    },

    // å¤åˆ¶çŠ¶æ€åˆ°å‰ªè´´æ¿
    async copyState() {
        try {
            const stateCopy = JSON.parse(JSON.stringify(GameState));
            stateCopy.chatHistory = `[${GameState.chatHistory.length} æ¡æ¶ˆæ¯]`;
            await navigator.clipboard.writeText(JSON.stringify(stateCopy, null, 2));
            showNotification('âœ… å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
        } catch (e) {
            showNotification('âŒ å¤åˆ¶å¤±è´¥', 'error');
        }
    },

    // ä¸‹è½½JSONæ–‡ä»¶
    downloadJSON(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${filename}_${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showNotification(`âœ… å·²å¯¼å‡º: ${a.download}`, 'success');
    },

    // æ¸…ç©ºé”™è¯¯æ—¥å¿—
    clearErrors() {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰é”™è¯¯æ—¥å¿—å—ï¼Ÿ')) {
            this.errors = [];
            this.updateBadges();
            this.updateDebugBtn();
            this.renderErrors();
            showNotification('ğŸ—‘ï¸ é”™è¯¯æ—¥å¿—å·²æ¸…ç©º', 'info');
        }
    },

    // æ¸…ç©ºAIæ—¥å¿—
    clearAI() {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰AIäº¤äº’æ—¥å¿—å—ï¼Ÿ')) {
            this.aiLogs = [];
            this.updateBadges();
            this.renderAI();
            showNotification('ğŸ—‘ï¸ AIæ—¥å¿—å·²æ¸…ç©º', 'info');
        }
    },

    // æ¸…ç©ºå…¨éƒ¨æ—¥å¿—
    clearAll() {
        if (confirm('ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ—¥å¿—å—ï¼Ÿ')) {
            this.errors = [];
            this.aiLogs = [];
            this.allLogs = [];
            this.updateBadges();
            this.updateDebugBtn();
            this.renderErrors();
            this.renderAI();
            this.renderAll();
            showNotification('ğŸ—‘ï¸ å…¨éƒ¨æ—¥å¿—å·²æ¸…ç©º', 'info');
        }
    }
};

// ==================== å…¨å±€é”™è¯¯æ•è· ====================
window.onerror = function (message, source, lineno, colno, error) {
    DebugLog.error('å…¨å±€é”™è¯¯', message, {
        source: source,
        line: lineno,
        column: colno,
        stack: error ? error.stack : null
    });
    return false;
};

window.addEventListener('unhandledrejection', function (event) {
    DebugLog.error('æœªå¤„ç†çš„Promiseé”™è¯¯', event.reason ? event.reason.message || String(event.reason) : 'æœªçŸ¥é”™è¯¯', {
        reason: event.reason
    });
});

// ==================== æ€§æ ¼è¯æ¡å®šä¹‰ ====================
const PersonalityTraits = [
    { id: 'pure', name: 'æ¸…çº¯', defaultDesc: 'å¤–è¡¨æ¸…çº¯å¯çˆ±ï¼Œå¯¹æ€§çŸ¥è¯†å‡ ä¹ä¸€æ— æ‰€çŸ¥ï¼Œå®¹æ˜“å®³ç¾è„¸çº¢' },
    { id: 'shy', name: 'å®³ç¾', defaultDesc: 'æ€§æ ¼å†…å‘è…¼è…†ï¼Œä¸å–„äºè¡¨è¾¾ï¼Œè¢«äººæ³¨è§†æ—¶ä¼šç´§å¼ ' },
    { id: 'gentle', name: 'æ¸©æŸ”', defaultDesc: 'æ€§æ ¼æ¸©å’Œä½“è´´ï¼Œå–„è§£äººæ„ï¼Œè¯´è¯è½»å£°ç»†è¯­' },
    { id: 'tsundere', name: 'å‚²å¨‡', defaultDesc: 'å˜´ä¸Šè¯´ä¸è¦èº«ä½“å´å¾ˆè¯šå®ï¼Œè¡¨é¢é«˜å†·å†…å¿ƒç«çƒ­' },
    { id: 'cold', name: 'é«˜å†·', defaultDesc: 'å¤–è¡¨å†·æ·¡ç–ç¦»ï¼Œä¸è½»æ˜“å¯¹äººæ•å¼€å¿ƒæ‰‰' },
    { id: 'cheerful', name: 'å¼€æœ—', defaultDesc: 'æ€§æ ¼é˜³å…‰æ´»æ³¼ï¼Œçˆ±ç¬‘çˆ±é—¹ï¼Œå®¹æ˜“å’Œäººæ‰“æˆä¸€ç‰‡' },
    { id: 'obedient', name: 'é¡ºä»', defaultDesc: 'æ€§æ ¼è½¯å¼±å®¹æ˜“è¢«æ”¯é…ï¼Œéš¾ä»¥æ‹’ç»ä»–äººçš„è¦æ±‚' },
    { id: 'proud', name: 'é«˜å‚²', defaultDesc: 'è‡ªå°Šå¿ƒæå¼ºï¼Œçœ‹ä¸èµ·æ™®é€šäººï¼Œä¸æ„¿ä½å¤´' },
    { id: 'innocent', name: 'å¤©ç„¶', defaultDesc: 'æ€æƒ³å•çº¯ä¸è°™ä¸–äº‹ï¼Œå®¹æ˜“è¢«äººæ¬ºéª—åˆ©ç”¨' },
    { id: 'sensual', name: 'é—·éªš', defaultDesc: 'å¤–è¡¨æ­£ç»å†…å¿ƒæ·«è¡ï¼Œæœ‰éšè—çš„æ¬²æœ›' },
    { id: 'passionate', name: 'çƒ­æƒ…', defaultDesc: 'æ€§æ ¼ç«çƒ­å¥”æ”¾ï¼Œæ„Ÿæƒ…å……æ²›ï¼Œå®¹æ˜“æŠ•å…¥' },
    { id: 'devoted', name: 'ä¸“ä¸€', defaultDesc: 'å¯¹æ„Ÿæƒ…æåº¦å¿ è¯šï¼Œä¸€æ—¦è®¤å®šå°±ä¸ä¼šæ”¹å˜' },
    { id: 'sensitive', name: 'æ•æ„Ÿ', defaultDesc: 'èº«ä½“å’Œå¿ƒç†éƒ½æå…¶æ•æ„Ÿï¼Œè½»å¾®åˆºæ¿€å°±æœ‰ååº”' },
    { id: 'masochist', name: 'æŠ–M', defaultDesc: 'æœ‰è¢«è™å€¾å‘ï¼Œè¢«ç²—æš´å¯¹å¾…åè€Œä¼šå…´å¥‹' },
    { id: 'exhibitionist', name: 'æš´éœ²ç™–', defaultDesc: 'æœ‰åœ¨ä»–äººé¢å‰æš´éœ²èº«ä½“çš„å†²åŠ¨å’Œå¿«æ„Ÿ' }
];

// ==================== æ¸¸æˆçŠ¶æ€ ====================
const GameState = {
    model: 'nalang-xl-0826',
    protagonist: { name: '', age: 22 },
    heroine: {
        name: '',
        age: 21,
        relation: '',
        identity: '',
        personality: [],
        personalityDesc: {},
        corruptionLevel: 1,
        corruptionExp: 5,
        infidelityValue: 0,
        virginStatus: 'å®Œç’§',
        cheatingCount: 0,
        sexStats: {
            oral: 0, handjob: 0, boobjob: 0, footjob: 0,
            anal: 0, condomSex: 0, creampie: 0, externalCum: 0,
            threesome: 0, intercrural: 0,
            orgasms: 0, cumExtracted: 0
        }
    },
    system: { level: 1, exp: 0, expToNext: 100, coins: 0 },
    shelter: {
        level: 1,
        name: 'æœ«ä¸–ä¹‹å…‰',
        items: ['å‹ç¼©é¥¼å¹²x3', 'çŸ¿æ³‰æ°´x2', 'æ¯›æ¯¯x1', 'åº”æ€¥ç¯x1']
    },
    gameTime: { year: 2025, month: 12, day: 15, hour: 14, minute: 30, weekday: 'æ˜ŸæœŸä¸€' },
    environment: { outdoorTemp: -35, indoorTemp: 18, weather: 'é˜´å†·', location: 'é¿éš¾æ‰€' },
    currentTasks: { daily: null, bounty: null },
    completedTasks: [],
    abilities: [],
    purchaseHistory: [],
    chatHistory: [],
    saves: [null, null, null],
    // æ–°å¢ï¼šæ€»ç»“ç›¸å…³çŠ¶æ€
    summaryIndex: -1,
    lastUserMessageIndex: -1,
    // æ–°å¢ï¼šå•†åº—æœç´¢ç¼“å­˜
    shopCache: {},  // æ ¼å¼: { "æœç´¢å…³é”®è¯": [å•†å“æ•°ç»„] }
    shopSearchHistory: []  // æœç´¢å†å²è®°å½•
};

// ==================== åˆå§‹åŒ– ====================
function initPersonalityTags() {
    const container = document.getElementById('personalityTags');
    container.innerHTML = PersonalityTraits.map(trait => `
<div class="personality-tag" data-id="${trait.id}" onclick="togglePersonalityTag('${trait.id}')">
  ${trait.name}
</div>
      `).join('');
    DebugLog.info('åˆå§‹åŒ–', 'æ€§æ ¼è¯æ¡åˆå§‹åŒ–å®Œæˆ', { count: PersonalityTraits.length });
}

function togglePersonalityTag(id) {
    const tag = document.querySelector(`.personality-tag[data-id="${id}"]`);
    tag.classList.toggle('selected');
    updatePersonalityDescriptions();
}

function updatePersonalityDescriptions() {
    const container = document.getElementById('personalityDescContainer');
    const selectedTags = document.querySelectorAll('.personality-tag.selected');

    if (selectedTags.length === 0) {
        container.classList.remove('active');
        container.innerHTML = '';
        return;
    }

    container.classList.add('active');
    container.innerHTML = Array.from(selectedTags).map(tag => {
        const id = tag.dataset.id;
        const trait = PersonalityTraits.find(t => t.id === id);
        const savedDesc = GameState.heroine.personalityDesc[id] || trait.defaultDesc;
        return `
  <div class="personality-desc-item">
    <div class="personality-desc-label">${trait.name}</div>
    <input type="text" class="personality-desc-input"
           data-id="${id}"
           value="${savedDesc}"
           onchange="updatePersonalityDesc('${id}', this.value)">
  </div>
`;
    }).join('');
}

function updatePersonalityDesc(id, value) {
    GameState.heroine.personalityDesc[id] = value;
}

function handleVirginChange() {
    const select = document.getElementById('virginSelect');
    const options = document.getElementById('virginOptions');

    if (select.value === 'no') {
        options.classList.add('active');
    } else {
        options.classList.remove('active');
    }
}

function selectVirginOption(element, value) {
    document.querySelectorAll('.radio-option').forEach(opt => opt.classList.remove('selected'));
    element.classList.add('selected');
    element.querySelector('input').checked = true;

    const customInput = document.getElementById('customVirginInput');
    if (value === 'custom') {
        customInput.classList.add('active');
    } else {
        customInput.classList.remove('active');
    }
}

// ==================== å·¥å…·å‡½æ•° ====================
function formatGameTime() {
    const t = GameState.gameTime;
    const pad = n => String(n).padStart(2, '0');
    return `${t.year}-${pad(t.month)}-${pad(t.day)} ${pad(t.hour)}:${pad(t.minute)}`;
}

function formatShortTime() {
    const t = GameState.gameTime;
    return `${String(t.hour).padStart(2, '0')}:${String(t.minute).padStart(2, '0')}`;
}

function getCorruptionStars(level) {
    return 'â­'.repeat(level) + 'â˜†'.repeat(5 - level);
}

function getWeekday(date) {
    const weekdays = ['æ˜ŸæœŸæ—¥', 'æ˜ŸæœŸä¸€', 'æ˜ŸæœŸäºŒ', 'æ˜ŸæœŸä¸‰', 'æ˜ŸæœŸå››', 'æ˜ŸæœŸäº”', 'æ˜ŸæœŸå…­'];
    return weekdays[date.getDay()];
}

function isBountyDay() {
    const wd = GameState.gameTime.weekday;
    return wd === 'æ˜ŸæœŸä¸€' || wd === 'æ˜ŸæœŸå››';
}

function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.innerHTML = message;
    document.body.appendChild(notification);
    setTimeout(() => {
        notification.style.animation = 'slideIn 0.3s ease reverse';
        setTimeout(() => notification.remove(), 300);
    }, 3000);
}

// ==================== åˆ¤æ–­æ˜¯å¦ä¸ºç§»åŠ¨ç«¯ ====================
function isMobile() {
    return window.innerWidth <= 900;
}

// ==================== ä¾§è¾¹æ åˆ‡æ¢ï¼ˆä¿®å¤ç§»åŠ¨ç«¯é—®é¢˜ï¼‰ ====================
function toggleSidePanel() {
    const panel = document.getElementById('sidePanel');
    const btn = document.getElementById('togglePanelBtn');
    const overlay = document.getElementById('mobileOverlay');

    if (isMobile()) {
        const isVisible = panel.classList.contains('mobile-visible');
        if (isVisible) {
            panel.classList.remove('mobile-visible');
            overlay.classList.remove('active');
            btn.classList.remove('active');
        } else {
            panel.classList.add('mobile-visible');
            overlay.classList.add('active');
            btn.classList.add('active');
        }
    } else {
        const chat = document.getElementById('chatContainer');
        panel.classList.toggle('collapsed');
        chat.classList.toggle('expanded');
        btn.classList.toggle('active');
    }
}

// ==================== å…³é—­ä¾§è¾¹æ ï¼ˆç‚¹å‡»é®ç½©æ—¶ï¼‰ ====================
function closeSidePanel() {
    const panel = document.getElementById('sidePanel');
    const btn = document.getElementById('togglePanelBtn');
    const overlay = document.getElementById('mobileOverlay');

    panel.classList.remove('mobile-visible');
    overlay.classList.remove('active');
    btn.classList.remove('active');
}

// ==================== Debugæ¨¡æ€æ¡† ====================
function openDebugModal() {
    document.getElementById('debugModal').classList.add('active');
    DebugLog.refreshState();
    DebugLog.renderErrors();
    DebugLog.renderAI();
    DebugLog.renderAll();
    DebugLog.info('Debug', 'æ‰“å¼€Debugé¢æ¿');
}

function closeDebugModal() {
    document.getElementById('debugModal').classList.remove('active');
}

function switchDebugTab(tabName) {
    document.querySelectorAll('.debug-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.debugTab === tabName);
    });
    document.querySelectorAll('.debug-content').forEach(content => {
        content.classList.toggle('active', content.id === `debug-${tabName}`);
    });

    if (tabName === 'errors') DebugLog.renderErrors();
    if (tabName === 'ai') DebugLog.renderAI();
    if (tabName === 'all') DebugLog.renderAll();
    if (tabName === 'state') DebugLog.refreshState();
}

// ==================== ä½œå¼Šæ¨¡æ€æ¡† ====================
function openCheatModal() {
    closeModelModal();
    document.getElementById('cheatModal').classList.add('active');
    loadCheatValues();
    DebugLog.info('ä½œå¼Šç³»ç»Ÿ', 'æ‰“å¼€ä½œå¼Šé¢æ¿');
}

function closeCheatModal() {
    document.getElementById('cheatModal').classList.remove('active');
}

// åŠ è½½å½“å‰æ¸¸æˆæ•°å€¼åˆ°ä½œå¼Šé¢æ¿
function loadCheatValues() {
    // ç³»ç»Ÿæ•°å€¼
    document.getElementById('cheatCoins').value = GameState.system.coins;
    document.getElementById('cheatExp').value = GameState.system.exp;
    document.getElementById('cheatLevel').value = GameState.system.level;

    // å¥³ä¸»è§’æ•°å€¼
    document.getElementById('cheatCorruptionLevel').value = GameState.heroine.corruptionLevel;
    document.getElementById('cheatCorruptionExp').value = GameState.heroine.corruptionExp;
    document.getElementById('cheatInfidelity').value = GameState.heroine.infidelityValue;
    document.getElementById('cheatCheatingCount').value = GameState.heroine.cheatingCount;
    document.getElementById('cheatVirginStatus').value = GameState.heroine.virginStatus;

    // æ€§ç»éªŒç»Ÿè®¡
    document.getElementById('cheatOral').value = GameState.heroine.sexStats.oral;
    document.getElementById('cheatHandjob').value = GameState.heroine.sexStats.handjob;
    document.getElementById('cheatBoobjob').value = GameState.heroine.sexStats.boobjob;
    document.getElementById('cheatFootjob').value = GameState.heroine.sexStats.footjob;
    document.getElementById('cheatAnal').value = GameState.heroine.sexStats.anal;
    document.getElementById('cheatCondomSex').value = GameState.heroine.sexStats.condomSex;
    document.getElementById('cheatCreampie').value = GameState.heroine.sexStats.creampie;
    document.getElementById('cheatExternalCum').value = GameState.heroine.sexStats.externalCum;
    document.getElementById('cheatThreesome').value = GameState.heroine.sexStats.threesome;
    document.getElementById('cheatIntercrural').value = GameState.heroine.sexStats.intercrural;
    document.getElementById('cheatOrgasms').value = GameState.heroine.sexStats.orgasms;
    document.getElementById('cheatCumExtracted').value = GameState.heroine.sexStats.cumExtracted;

    // ç¯å¢ƒè®¾ç½®
    document.getElementById('cheatOutdoorTemp').value = GameState.environment.outdoorTemp;
    document.getElementById('cheatIndoorTemp').value = GameState.environment.indoorTemp;
    document.getElementById('cheatLocation').value = GameState.environment.location;
    document.getElementById('cheatWeather').value = GameState.environment.weather;

    // é¿éš¾æ‰€è®¾ç½®
    document.getElementById('cheatShelterLevel').value = GameState.shelter.level;
    document.getElementById('cheatShelterName').value = GameState.shelter.name;

    DebugLog.info('ä½œå¼Šç³»ç»Ÿ', 'å·²åŠ è½½å½“å‰æ¸¸æˆæ•°å€¼');
}

// åº”ç”¨ä½œå¼Šä¿®æ”¹
function applyCheat() {
    // ç³»ç»Ÿæ•°å€¼
    GameState.system.coins = parseInt(document.getElementById('cheatCoins').value) || 0;
    GameState.system.exp = parseInt(document.getElementById('cheatExp').value) || 0;
    GameState.system.level = parseInt(document.getElementById('cheatLevel').value) || 1;

    // å¥³ä¸»è§’æ•°å€¼
    GameState.heroine.corruptionLevel = Math.min(5, Math.max(1, parseInt(document.getElementById('cheatCorruptionLevel').value) || 1));
    GameState.heroine.corruptionExp = Math.min(100, Math.max(0, parseInt(document.getElementById('cheatCorruptionExp').value) || 0));
    GameState.heroine.infidelityValue = Math.min(100, Math.max(0, parseInt(document.getElementById('cheatInfidelity').value) || 0));
    GameState.heroine.cheatingCount = parseInt(document.getElementById('cheatCheatingCount').value) || 0;
    GameState.heroine.virginStatus = document.getElementById('cheatVirginStatus').value || 'å®Œç’§';

    // æ€§ç»éªŒç»Ÿè®¡
    GameState.heroine.sexStats.oral = parseInt(document.getElementById('cheatOral').value) || 0;
    GameState.heroine.sexStats.handjob = parseInt(document.getElementById('cheatHandjob').value) || 0;
    GameState.heroine.sexStats.boobjob = parseInt(document.getElementById('cheatBoobjob').value) || 0;
    GameState.heroine.sexStats.footjob = parseInt(document.getElementById('cheatFootjob').value) || 0;
    GameState.heroine.sexStats.anal = parseInt(document.getElementById('cheatAnal').value) || 0;
    GameState.heroine.sexStats.condomSex = parseInt(document.getElementById('cheatCondomSex').value) || 0;
    GameState.heroine.sexStats.creampie = parseInt(document.getElementById('cheatCreampie').value) || 0;
    GameState.heroine.sexStats.externalCum = parseInt(document.getElementById('cheatExternalCum').value) || 0;
    GameState.heroine.sexStats.threesome = parseInt(document.getElementById('cheatThreesome').value) || 0;
    GameState.heroine.sexStats.intercrural = parseInt(document.getElementById('cheatIntercrural').value) || 0;
    GameState.heroine.sexStats.orgasms = parseInt(document.getElementById('cheatOrgasms').value) || 0;
    GameState.heroine.sexStats.cumExtracted = parseInt(document.getElementById('cheatCumExtracted').value) || 0;

    // ç¯å¢ƒè®¾ç½®
    GameState.environment.outdoorTemp = parseInt(document.getElementById('cheatOutdoorTemp').value) || -35;
    GameState.environment.indoorTemp = parseInt(document.getElementById('cheatIndoorTemp').value) || 18;
    GameState.environment.location = document.getElementById('cheatLocation').value || 'é¿éš¾æ‰€';
    GameState.environment.weather = document.getElementById('cheatWeather').value || 'é˜´å†·';

    // é¿éš¾æ‰€è®¾ç½®
    GameState.shelter.level = parseInt(document.getElementById('cheatShelterLevel').value) || 1;
    GameState.shelter.name = document.getElementById('cheatShelterName').value || 'æœ«ä¸–ä¹‹å…‰';

    // æ›´æ–°UI
    updateAllUI();

    // å…³é—­ä½œå¼Šé¢æ¿
    closeCheatModal();

    showNotification('âœ… ä½œå¼Šæ•°å€¼å·²åº”ç”¨ï¼', 'success');
    DebugLog.success('ä½œå¼Šç³»ç»Ÿ', 'å·²åº”ç”¨ä½œå¼Šä¿®æ”¹', {
        coins: GameState.system.coins,
        level: GameState.system.level,
        corruptionLevel: GameState.heroine.corruptionLevel
    });
}

// ==================== ä»»åŠ¡ç³»ç»Ÿ ====================
function getTaskLevelDescription(level, isBounty = false) {
    const effectiveLevel = isBounty ? Math.min(level + 1, 5) : level;
    const descriptions = {
        1: 'ç®€å•çš„èº«ä½“æ¥è§¦ï¼ˆæ¡æ‰‹ã€æ‹¥æŠ±ã€çœ¼ç¥æ¥è§¦ç­‰ï¼‰',
        2: 'è£¸éœ²å’Œè§¦æ‘¸èº«ä½“ï¼ˆå±•ç¤ºèº«æã€è¢«æ‘¸èƒ¸ã€è¢«æ‘¸è‡€ç­‰ï¼‰',
        3: 'å£äº¤å’Œè¶³äº¤ç­‰éæ’å…¥æ€§è¡Œä¸ºï¼ˆå£äº¤ã€è¶³äº¤ã€ä¹³äº¤ç­‰ï¼Œé¿å…æ€§äº¤ï¼‰',
        4: 'å®Œæ•´çš„æ€§äº¤è¡Œä¸ºï¼ˆé˜´é“æ€§äº¤ã€è‚›äº¤ã€å†…å°„ç­‰ï¼‰',
        5: isBounty ? 'é•¿æ—¶é—´çš„è½®å¥¸ã€å…¬å…±è‚‰ä¾¿å™¨ã€æç«¯ç¾¤äº¤ç­‰' : 'ç¾¤äº¤å’Œå¤šPè¡Œä¸ºï¼ˆ3Pã€è½®å¥¸ã€å¤šäººæ€§äº¤ç­‰ï¼‰'
    };
    return descriptions[effectiveLevel] || descriptions[1];
}

async function generateDailyTask() {
    const level = GameState.heroine.corruptionLevel;
    const levelDesc = getTaskLevelDescription(level, false);
    const container = document.getElementById('dailyTaskContainer');

    container.innerHTML = `
<div class="task-loading">
  <div class="task-loading-spinner"></div>
  æ­£åœ¨ç”Ÿæˆä»»åŠ¡...
</div>
      `;

    DebugLog.info('ä»»åŠ¡ç³»ç»Ÿ', 'å¼€å§‹ç”Ÿæˆæ¯æ—¥ä»»åŠ¡', { level: level });

    const prompt = `ä½ æ˜¯æœ«ä¸–å¯å–ç”Ÿå­˜æ¸¸æˆçš„ä»»åŠ¡ç”Ÿæˆç³»ç»Ÿã€‚è¿™æ˜¯ä¸€æ¬¾ä»¥å¯å–ï¼ˆNTRï¼‰ä¸ºæ ¸å¿ƒç©æ³•çš„æˆäººæ¸¸æˆã€‚
ã€èƒŒæ™¯è®¾å®šã€‘
æå¯’æœ«ä¸–ï¼Œæ–‡æ˜å´©æºƒã€‚ä¸»è§’${GameState.protagonist.name}å’Œå¥³å‹${GameState.heroine.name}èº²åœ¨é¿éš¾æ‰€ç”Ÿå­˜ã€‚
ä¸»è§’æ‹¥æœ‰"å¯å–ç³»ç»Ÿ"ï¼Œé€šè¿‡è®©å¥³å‹ä¸å…¶ä»–ç”·æ€§å‘ç”Ÿäº²å¯†æ¥è§¦æ¥è·å–èµ„æºã€‚
å¥³ä¸»è§’ï¼š${GameState.heroine.name}ï¼Œ${GameState.heroine.age}å²ï¼Œ${GameState.heroine.identity}ï¼Œæ˜¯ä¸»è§’çš„${GameState.heroine.relation}
ã€å½“å‰æ·«ä¹±ç­‰çº§ã€‘${level}æ˜Ÿ
ã€ä»»åŠ¡å°ºåº¦è¦æ±‚ã€‘${levelDesc}
ã€ä»»åŠ¡è®¾è®¡è§„åˆ™ã€‘
1. ä»»åŠ¡å¿…é¡»æ˜¯è®©å¥³ä¸»è§’ä¸ä»»æ„ã€å…¶ä»–ç”·æ€§ã€‘å‘ç”ŸæŒ‡å®šå°ºåº¦çš„äº²å¯†æ¥è§¦
2. ä»»åŠ¡å¯¹è±¡æ²¡æœ‰ä»»ä½•é™åˆ¶,ä½†ä¸èƒ½æ˜¯${GameState.protagonist.name}
è¯·ç”Ÿæˆ1ä¸ªæ¯æ—¥ä»»åŠ¡ï¼Œä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ï¼š
{
  "content": "ä»»åŠ¡æè¿°ï¼Œç®€å•å™è¿°ä»»åŠ¡è¦æ±‚",
  "coins": ${level * 15}åˆ°${level * 30}ä¹‹é—´çš„æ•´æ•°,
  "exp": ${level * 20}åˆ°${level * 40}ä¹‹é—´çš„æ•´æ•°
}
ã€ç¤ºä¾‹å‚è€ƒã€‘
1æ˜Ÿ: "è®©${GameState.heroine.name}å¯»æ‰¾ä»»æ„ç”·æ€§ï¼Œå…è®¸å¯¹æ–¹æ¡ä½å¥¹çš„æ‰‹å¹¶å‡è§†å¥¹30ç§’"
2æ˜Ÿ: "è®©${GameState.heroine.name}åœ¨ä»»æ„ç”·æ€§é¢å‰è„±æ‰ä¸Šè¡£è®©å…¶æŠšæ‘¸æ£€æŸ¥å¥¹çš„èƒ¸éƒ¨"
3æ˜Ÿ: "è®©${GameState.heroine.name}ç»™ä»»æ„ç”·æ€§å£äº¤ä¸€æ¬¡å¹¶åç²¾"
4æ˜Ÿ: "è®©${GameState.heroine.name}è¢«äººä»¥ç”·æ€§æ’å…¥å¹¶å°„ç²¾"
5æ˜Ÿ: "è®©${GameState.heroine.name}ä¸€å¤©å†…è¢«è‡³å°‘4åç”·æ€§ä¸­å‡º"
åªè¿”å›JSONï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

    const logId = DebugLog.aiRequest('ç”Ÿæˆæ¯æ—¥ä»»åŠ¡', prompt, GameState.model);

    try {
        let fullResponse = '';
        await dzmm.completions({
            model: GameState.model,
            messages: [{ role: 'user', content: prompt }],
            maxTokens: 500
        }, (content, done) => {
            fullResponse = content;
            if (done) {
                DebugLog.aiResponse(logId, fullResponse, true);

                try {
                    const jsonMatch = fullResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const taskData = JSON.parse(jsonMatch[0]);
                        GameState.currentTasks.daily = {
                            type: 'æ¯æ—¥ä»»åŠ¡',
                            content: taskData.content,
                            rewards: { coins: taskData.coins, exp: taskData.exp },
                            level: level,
                            status: 'pending'
                        };
                        updateTaskUI();
                        DebugLog.success('ä»»åŠ¡ç³»ç»Ÿ', 'æ¯æ—¥ä»»åŠ¡ç”ŸæˆæˆåŠŸ', taskData);
                    } else {
                        throw new Error('æ— æ³•ä»å“åº”ä¸­è§£æJSON');
                    }
                } catch (e) {
                    DebugLog.error('ä»»åŠ¡ç³»ç»Ÿ', 'æ¯æ—¥ä»»åŠ¡JSONè§£æå¤±è´¥', {
                        error: e.message,
                        response: fullResponse
                    });
                    container.innerHTML = `<div style="color: var(--accent-red); font-size: 0.8rem;">ä»»åŠ¡ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•</div>`;
                }
            }
        });
    } catch (error) {
        DebugLog.aiResponse(logId, null, false, error.message);
        DebugLog.error('ä»»åŠ¡ç³»ç»Ÿ', 'æ¯æ—¥ä»»åŠ¡APIè¯·æ±‚å¤±è´¥', { error: error.message });
        container.innerHTML = `<div style="color: var(--accent-red); font-size: 0.8rem;">ä»»åŠ¡ç”Ÿæˆå¤±è´¥: ${error.message}</div>`;
    }
}

async function generateBountyTask() {
    if (!isBountyDay()) {
        showNotification('æ‚¬èµä»»åŠ¡ä»…åœ¨å‘¨ä¸€/å‘¨å››å¼€æ”¾', 'warning');
        DebugLog.warning('ä»»åŠ¡ç³»ç»Ÿ', 'å°è¯•åœ¨éæ‚¬èµæ—¥ç”Ÿæˆæ‚¬èµä»»åŠ¡', { weekday: GameState.gameTime.weekday });
        return;
    }

    const level = GameState.heroine.corruptionLevel;
    const effectiveLevel = Math.min(level + 1, 5);
    const levelDesc = getTaskLevelDescription(level, true);
    const container = document.getElementById('bountyTaskContainer');

    container.innerHTML = `
<div class="task-loading">
  <div class="task-loading-spinner"></div>
  æ­£åœ¨ç”Ÿæˆæ‚¬èµä»»åŠ¡...
</div>
      `;

    DebugLog.info('ä»»åŠ¡ç³»ç»Ÿ', 'å¼€å§‹ç”Ÿæˆæ‚¬èµä»»åŠ¡', { level: level, effectiveLevel: effectiveLevel });

    const prompt = `ä½ æ˜¯æœ«ä¸–å¯å–ç”Ÿå­˜æ¸¸æˆçš„æ‚¬èµä»»åŠ¡ç”Ÿæˆç³»ç»Ÿã€‚è¿™æ˜¯ä¸€æ¬¾ä»¥å¯å–ï¼ˆNTRï¼‰ä¸ºæ ¸å¿ƒç©æ³•çš„æˆäººæ¸¸æˆã€‚
ã€èƒŒæ™¯è®¾å®šã€‘
æå¯’æœ«ä¸–ï¼Œæ–‡æ˜å´©æºƒã€‚ä¸»è§’${GameState.protagonist.name}å’Œå¥³å‹${GameState.heroine.name}èº²åœ¨é¿éš¾æ‰€ç”Ÿå­˜ã€‚
ä¸»è§’æ‹¥æœ‰"å¯å–ç³»ç»Ÿ"ï¼Œé€šè¿‡è®©å¥³å‹ä¸å…¶ä»–ç”·æ€§å‘ç”Ÿäº²å¯†æ¥è§¦æ¥è·å–èµ„æºã€‚
å¥³ä¸»è§’ï¼š${GameState.heroine.name}ï¼Œ${GameState.heroine.age}å²ï¼Œ${GameState.heroine.identity}ï¼Œæ˜¯ä¸»è§’çš„${GameState.heroine.relation}
ã€å½“å‰æ·«ä¹±ç­‰çº§ã€‘${level}æ˜Ÿ
ã€æ‚¬èµéš¾åº¦ã€‘${effectiveLevel}æ˜Ÿï¼ˆæ¯”æ¯æ—¥ä»»åŠ¡é«˜ä¸€çº§ï¼Œæ›´å±é™©æ›´åˆºæ¿€ï¼‰
ã€ä»»åŠ¡å°ºåº¦è¦æ±‚ã€‘${levelDesc}
ã€ä»»åŠ¡è®¾è®¡è§„åˆ™ã€‘
1. æ‚¬èµä»»åŠ¡æ¯”æ¯æ—¥ä»»åŠ¡æ›´æç«¯ï¼Œæ¶‰åŠæ›´å¤šäººæ•°æˆ–æ›´ç¾è€»çš„åœºæ™¯
2. ä»»åŠ¡å¯¹è±¡æ²¡æœ‰ä»»ä½•é™åˆ¶ï¼Œä½†ä¸èƒ½æ˜¯${GameState.protagonist.name}
3. å¯ä»¥æ¶‰åŠå…¬å¼€åœºåˆã€å¤šäººã€è¿ç»­æ€§è¡Œä¸º
è¯·ç”Ÿæˆ1ä¸ªæ‚¬èµä»»åŠ¡ï¼Œä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹JSONæ ¼å¼è¿”å›ï¼š
{
  "content": "ä»»åŠ¡æè¿°ï¼Œç®€å•å™è¿°ä»»åŠ¡è¦æ±‚ï¼Œè¦æ¯”æ¯æ—¥ä»»åŠ¡æ›´åˆºæ¿€",
  "coins": ${effectiveLevel * 30}åˆ°${effectiveLevel * 50}ä¹‹é—´çš„æ•´æ•°,
  "exp": ${effectiveLevel * 40}åˆ°${effectiveLevel * 60}ä¹‹é—´çš„æ•´æ•°
}
ã€ç¤ºä¾‹å‚è€ƒã€‘
1æ˜Ÿ: "è®©${GameState.heroine.name}åœ¨å…¬å…±åœºæ‰€éœ²å‡ºèƒ¸éƒ¨"
2æ˜Ÿ: "è®©${GameState.heroine.name}è¢«äººä»¥ç”·æ€§ç©å¼„ä¹³å¤´åˆ°é«˜æ½®"
3æ˜Ÿ: "è®©${GameState.heroine.name}åœ¨ä¸€å¤©å†…è‡³å°‘ç»™ä¸¤äººå£äº¤åç²¾"
4æ˜Ÿ: "è®©${GameState.heroine.name}åœ¨ä¸€å¤©å†…è‡³å°‘è¢«4äººä¸­å‡ºå°„ç²¾"
5æ˜Ÿ: "è®©${GameState.heroine.name}åœ¨å…¬å…±å•æ‰€ä½œä¸ºå…¬å…±è‚‰ä¾¿å™¨ç›´åˆ°ç¬¬äºŒå¤©"
åªè¿”å›JSONï¼Œä¸è¦ä»»ä½•å…¶ä»–æ–‡å­—ã€‚`;

    const logId = DebugLog.aiRequest('ç”Ÿæˆæ‚¬èµä»»åŠ¡', prompt, GameState.model);

    try {
        let fullResponse = '';
        await dzmm.completions({
            model: GameState.model,
            messages: [{ role: 'user', content: prompt }],
            maxTokens: 600
        }, (content, done) => {
            fullResponse = content;
            if (done) {
                DebugLog.aiResponse(logId, fullResponse, true);

                try {
                    const jsonMatch = fullResponse.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const taskData = JSON.parse(jsonMatch[0]);
                        GameState.currentTasks.bounty = {
                            type: 'æ‚¬èµä»»åŠ¡',
                            content: taskData.content,
                            rewards: { coins: taskData.coins, exp: taskData.exp },
                            level: effectiveLevel,
                            status: 'pending'
                        };
                        updateTaskUI();
                        DebugLog.success('ä»»åŠ¡ç³»ç»Ÿ', 'æ‚¬èµä»»åŠ¡ç”ŸæˆæˆåŠŸ', taskData);
                    } else {
                        throw new Error('æ— æ³•ä»å“åº”ä¸­è§£æJSON');
                    }
                } catch (e) {
                    DebugLog.error('ä»»åŠ¡ç³»ç»Ÿ', 'æ‚¬èµä»»åŠ¡JSONè§£æå¤±è´¥', {
                        error: e.message,
                        response: fullResponse
                    });
                    container.innerHTML = `<div style="color: var(--accent-red); font-size: 0.8rem;">æ‚¬èµä»»åŠ¡ç”Ÿæˆå¤±è´¥</div>`;
                }
            }
        });
    } catch (error) {
        DebugLog.aiResponse(logId, null, false, error.message);
        DebugLog.error('ä»»åŠ¡ç³»ç»Ÿ', 'æ‚¬èµä»»åŠ¡APIè¯·æ±‚å¤±è´¥', { error: error.message });
        container.innerHTML = `<div style="color: var(--accent-red); font-size: 0.8rem;">æ‚¬èµä»»åŠ¡ç”Ÿæˆå¤±è´¥</div>`;
    }
}

function completeTask(taskType) {
    const task = GameState.currentTasks[taskType];
    if (!task || task.status === 'completed') return;

    task.status = 'completed';
    GameState.system.coins += task.rewards.coins;
    GameState.system.exp += task.rewards.exp;

    DebugLog.info('ä»»åŠ¡ç³»ç»Ÿ', `å®Œæˆ${taskType === 'daily' ? 'æ¯æ—¥' : 'æ‚¬èµ'}ä»»åŠ¡`, {
        task: task.content,
        rewards: task.rewards
    });

    while (GameState.system.exp >= GameState.system.expToNext) {
        GameState.system.exp -= GameState.system.expToNext;
        GameState.system.level++;
        GameState.system.expToNext = Math.floor(GameState.system.expToNext * 1.5);
        showNotification(`ğŸ‰ å¯å–ç­‰çº§æå‡è‡³ Lv.${GameState.system.level}ï¼`, 'success');
        DebugLog.success('å‡çº§ç³»ç»Ÿ', `ç­‰çº§æå‡åˆ° Lv.${GameState.system.level}`);
    }

    GameState.heroine.infidelityValue = Math.min(100, GameState.heroine.infidelityValue + 5);
    GameState.heroine.corruptionExp += 15;
    if (GameState.heroine.corruptionExp >= 100 && GameState.heroine.corruptionLevel < 5) {
        GameState.heroine.corruptionExp = 0;
        GameState.heroine.corruptionLevel++;
        showNotification(`ğŸ’” ${GameState.heroine.name}çš„æ·«ä¹±ç­‰çº§æå‡è‡³ ${GameState.heroine.corruptionLevel}æ˜Ÿï¼`, 'info');
        DebugLog.info('å •è½ç³»ç»Ÿ', `æ·«ä¹±ç­‰çº§æå‡åˆ° ${GameState.heroine.corruptionLevel}æ˜Ÿ`);
    }

    GameState.completedTasks.push({ ...task, completedAt: formatGameTime() });
    showNotification(`âœ… ä»»åŠ¡å®Œæˆï¼è·å¾— ${task.rewards.coins}ğŸ’° ${task.rewards.exp}ç»éªŒ`, 'success');

    updateAllUI();
}

// ==================== æ—¶é—´ç³»ç»Ÿ ====================
async function advanceTime(hours) {
    const t = GameState.gameTime;
    const date = new Date(t.year, t.month - 1, t.day, t.hour, t.minute);
    date.setHours(date.getHours() + hours);

    GameState.gameTime = {
        year: date.getFullYear(),
        month: date.getMonth() + 1,
        day: date.getDate(),
        hour: date.getHours(),
        minute: date.getMinutes(),
        weekday: getWeekday(date)
    };

    DebugLog.info('æ—¶é—´ç³»ç»Ÿ', `æ—¶é—´æ¨è¿› ${hours} å°æ—¶`, { newTime: formatGameTime() });

    updateAllUI();

    if (hours >= 24) {
        const days = Math.floor(hours / 24);
        showTypingIndicator();

        const prompt = `æ—¶é—´å¿«è¿›äº†${days}å¤©ã€‚è¯·ç®€è¦æè¿°è¿™${days}å¤©å†…å‘ç”Ÿçš„äº‹æƒ…ï¼š

1. å¥³ä¸»è§’${GameState.heroine.name}æ˜¯å¦æ‰§è¡Œäº†ä»»åŠ¡ï¼Ÿ
2. ä»»åŠ¡è¿‡ç¨‹ä¸­å‘ç”Ÿäº†ä»€ä¹ˆï¼Ÿ
3. å¥¹çš„çŠ¶æ€æœ‰ä»€ä¹ˆå˜åŒ–ï¼Ÿ

å½“å‰æ·«ä¹±ç­‰çº§ï¼š${GameState.heroine.corruptionLevel}æ˜Ÿ
å½“å‰ä»»åŠ¡ï¼š${GameState.currentTasks.daily ? GameState.currentTasks.daily.content : 'æ— '}

è¯·ç”¨600-800å­—æè¿°ï¼ŒåŒ…å«é€‚å½“çš„è‰²æƒ…ç»†èŠ‚ã€‚
æœ€åç”¨ã€çŠ¶æ€å˜åŒ–ã€‘æ ‡æ³¨æ•°å€¼å˜åŠ¨ã€‚`;

        await sendToAI(prompt);
    } else {
        showNotification(`â° æ—¶é—´æ¨è¿›äº†${hours}å°æ—¶`, 'info');
    }
}

// ==================== UIæ›´æ–° ====================
function updateAllUI() {
    // å¤´éƒ¨
    document.getElementById('headerCoins').textContent = GameState.system.coins;
    document.getElementById('headerLevel').textContent = `Lv.${GameState.system.level}`;
    document.getElementById('headerTime').textContent = formatShortTime();
    document.getElementById('headerCorruption').textContent = GameState.heroine.corruptionLevel;

    // å…¨å±€çŠ¶æ€
    document.getElementById('gameTime').textContent = formatGameTime();
    document.getElementById('gameWeekday').textContent = GameState.gameTime.weekday;
    document.getElementById('gameLocation').textContent = GameState.environment.location;
    document.getElementById('outdoorTemp').textContent = `${GameState.environment.outdoorTemp}Â°C`;
    document.getElementById('indoorTemp').textContent = `${GameState.environment.indoorTemp}Â°C`;
    document.getElementById('weather').textContent = GameState.environment.weather;

    // ç³»ç»Ÿ
    document.getElementById('systemLevel').textContent = `Lv.${GameState.system.level}`;
    document.getElementById('systemExp').textContent = `${GameState.system.exp} / ${GameState.system.expToNext}`;
    document.getElementById('systemCoins').textContent = `${GameState.system.coins} ğŸ’°`;

    // é¿éš¾æ‰€
    document.getElementById('shelterLevel').textContent = `Lv.${GameState.shelter.level} ${GameState.shelter.name}`;
    document.getElementById('inventoryList').innerHTML = GameState.shelter.items.map(item =>
        `<span class="inventory-item">${item}</span>`
    ).join('');

    // èƒ½åŠ›
    const abilitiesList = document.getElementById('abilitiesList');
    if (GameState.abilities.length > 0) {
        abilitiesList.innerHTML = GameState.abilities.map(a => `
  <div class="ability-card">
    <div class="ability-name">${a.name}</div>
    <div class="ability-desc">${a.desc}</div>
  </div>
`).join('');
    } else {
        abilitiesList.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">æš‚æ— ç‰¹æ®Šèƒ½åŠ›</div>';
    }

    // å¥³ä¸»è§’
    document.getElementById('heroineDisplayName').textContent = GameState.heroine.name;
    document.getElementById('heroineDisplayRelation').textContent = GameState.heroine.relation;
    document.getElementById('heroineDisplayAge').textContent = `${GameState.heroine.age}å²`;
    document.getElementById('heroineDisplayIdentity').textContent = GameState.heroine.identity;
    document.getElementById('heroineDisplayPersonality').textContent =
        GameState.heroine.personality.length > 0 ?
            GameState.heroine.personality.map(id => PersonalityTraits.find(t => t.id === id)?.name).join('ã€') : '-';

    // å •è½æ•°æ®
    document.getElementById('corruptionStars').textContent = getCorruptionStars(GameState.heroine.corruptionLevel);
    document.getElementById('corruptionBar').style.width = `${GameState.heroine.corruptionExp}%`;
    document.getElementById('infidelityValue').textContent = `${GameState.heroine.infidelityValue}%`;
    document.getElementById('virginStatus').textContent = GameState.heroine.virginStatus;
    document.getElementById('cheatingCount').textContent = GameState.heroine.cheatingCount;

    // æ€§ç»éªŒ
    const stats = GameState.heroine.sexStats;
    const statsLabels = {
        oral: 'å£éƒ¨ä¾å¥‰', handjob: 'æ‰‹éƒ¨ä¾å¥‰', boobjob: 'ä¹³éƒ¨ä¾å¥‰', footjob: 'è¶³éƒ¨ä¾å¥‰',
        anal: 'è‚›é—¨æ€§äº¤', condomSex: 'æˆ´å¥—æ€§äº¤', creampie: 'æ— å¥—å†…å°„', externalCum: 'ä½“å¤–å°„ç²¾',
        threesome: '3P/ä¹±äº¤', intercrural: 'ç´ è‚¡',
        orgasms: 'é«˜æ½®æ¬¡æ•°', cumExtracted: 'æ¦¨ç²¾(ml)'
    };
    document.getElementById('sexStatsGrid').innerHTML = Object.entries(stats).map(([key, value]) => `
<div class="sex-stat">
  <span class="status-label">${statsLabels[key]}</span>
  <span class="status-value ${value > 0 ? 'pink' : ''}">${value}</span>
</div>
      `).join('');

    updateTaskUI();

    if (document.getElementById('shopCoins')) {
        document.getElementById('shopCoins').textContent = `${GameState.system.coins} ğŸ’°`;
    }
}

function updateTaskUI() {
    // æ¯æ—¥ä»»åŠ¡
    const dailyContainer = document.getElementById('dailyTaskContainer');
    const task = GameState.currentTasks.daily;

    if (task) {
        const canRefresh = task.status === 'completed';
        dailyContainer.innerHTML = `
  <div class="task-card ${task.status === 'completed' ? 'completed' : ''}">
    <div class="task-header">
      <div class="task-type">ğŸ’š æ¯æ—¥ä»»åŠ¡</div>
      <div class="task-level">${task.level}æ˜Ÿéš¾åº¦</div>
    </div>
    <div class="task-content">${task.content}</div>
    <div class="task-rewards">
      <span class="task-reward coins">ğŸ’° +${task.rewards.coins}</span>
      <span class="task-reward exp">ğŸ“ˆ +${task.rewards.exp}</span>
    </div>
    <span class="task-status ${task.status}">${task.status === 'pending' ? 'è¿›è¡Œä¸­' : 'å·²å®Œæˆ'}</span>
    <div class="task-actions">
      ${task.status === 'pending' ? `
        <button class="task-btn complete" onclick="completeTask('daily')">âœ… å®Œæˆä»»åŠ¡</button>
      ` : ''}
      <button class="task-btn refresh" onclick="generateDailyTask()" ${!canRefresh ? 'disabled' : ''}>
        ğŸ”„ ${canRefresh ? 'åˆ·æ–°ä»»åŠ¡' : 'å®Œæˆåå¯åˆ·æ–°'}
      </button>
    </div>
  </div>
`;
    } else {
        dailyContainer.innerHTML = `
  <div class="task-card">
    <div class="task-content" style="color: var(--text-muted);">æš‚æ— ä»»åŠ¡</div>
    <div class="task-actions">
      <button class="task-btn refresh" onclick="generateDailyTask()">ğŸ”„ ç”Ÿæˆä»»åŠ¡</button>
    </div>
  </div>
`;
    }

    // æ‚¬èµä»»åŠ¡
    const bountyContainer = document.getElementById('bountyTaskContainer');
    const bounty = GameState.currentTasks.bounty;
    const canShowBounty = isBountyDay();

    if (bounty) {
        const canRefresh = bounty.status === 'completed' && canShowBounty;
        bountyContainer.innerHTML = `
  <div class="task-card bounty ${bounty.status === 'completed' ? 'completed' : ''}">
    <div class="task-header">
      <div class="task-type">ğŸ’› æ‚¬èµä»»åŠ¡</div>
      <div class="task-level">${bounty.level}æ˜Ÿéš¾åº¦</div>
    </div>
    <div class="task-content">${bounty.content}</div>
    <div class="task-rewards">
      <span class="task-reward coins">ğŸ’° +${bounty.rewards.coins}</span>
      <span class="task-reward exp">ğŸ“ˆ +${bounty.rewards.exp}</span>
    </div>
    <span class="task-status ${bounty.status}">${bounty.status === 'pending' ? 'è¿›è¡Œä¸­' : 'å·²å®Œæˆ'}</span>
    <div class="task-actions">
      ${bounty.status === 'pending' ? `
        <button class="task-btn complete" onclick="completeTask('bounty')">âœ… å®Œæˆä»»åŠ¡</button>
      ` : ''}
      ${canShowBounty ? `
        <button class="task-btn refresh" onclick="generateBountyTask()" ${!canRefresh ? 'disabled' : ''}>
          ğŸ”„ ${canRefresh ? 'åˆ·æ–°æ‚¬èµ' : 'å®Œæˆåå¯åˆ·æ–°'}
        </button>
      ` : ''}
    </div>
  </div>
`;
    } else if (canShowBounty) {
        bountyContainer.innerHTML = `
  <div class="task-card bounty">
    <div class="task-content" style="color: var(--text-muted);">ä»Šå¤©æ˜¯æ‚¬èµæ—¥ï¼</div>
    <div class="task-actions">
      <button class="task-btn refresh" onclick="generateBountyTask()">ğŸ”„ ç”Ÿæˆæ‚¬èµä»»åŠ¡</button>
    </div>
  </div>
`;
    } else {
        bountyContainer.innerHTML = `
  <div style="color: var(--text-muted); font-size: 0.75rem;">
    æ‚¬èµä»»åŠ¡ä»…åœ¨å‘¨ä¸€/å‘¨å››å¼€æ”¾<br>
    å½“å‰: ${GameState.gameTime.weekday}
  </div>
`;
    }

    // å·²å®Œæˆä»»åŠ¡
    const completedContainer = document.getElementById('completedTasksContainer');
    if (GameState.completedTasks.length > 0) {
        completedContainer.innerHTML = GameState.completedTasks.slice(-5).reverse().map(t => `
  <div class="task-card completed" style="opacity: 0.6;">
    <div class="task-content" style="font-size: 0.75rem;">${t.content}</div>
    <span class="task-status completed">âœ… å·²å®Œæˆ</span>
  </div>
`).join('');
    } else {
        completedContainer.innerHTML = '<div style="color: var(--text-muted); font-size: 0.75rem;">æš‚æ— å®Œæˆè®°å½•</div>';
    }
}

function switchTab(tabName) {
    document.querySelectorAll('.panel-tab').forEach(tab => {
        tab.classList.toggle('active', tab.dataset.tab === tabName);
    });
    document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.id === `tab-${tabName}`);
    });
}

// ==================== æ¶ˆæ¯ç³»ç»Ÿ ====================
function addMessage(role, content, isSummary = false) {
    const container = document.getElementById('chatMessages');
    const div = document.createElement('div');
    div.className = `message ${role}${isSummary ? ' summary' : ''}`;

    const messageIndex = GameState.chatHistory.length;
    const sender = role === 'user' ? GameState.protagonist.name : 'ç³»ç»Ÿå™è¿°';
    const summaryBadge = isSummary ? '<span class="summary-badge">ğŸ“ å‰§æƒ…æ€»ç»“</span>' : '';

    div.innerHTML = `
<div class="message-sender">${sender}${summaryBadge}</div>
<div class="message-bubble">${formatContent(content)}</div>
      `;

    div.dataset.messageIndex = messageIndex;

    container.appendChild(div);
    container.scrollTop = container.scrollHeight;

    GameState.chatHistory.push({ role, content, isSummary: isSummary });

    if (isSummary) {
        GameState.summaryIndex = messageIndex;
        DebugLog.info('æ€»ç»“ç³»ç»Ÿ', 'å·²åˆ›å»ºæ€»ç»“ï¼Œä¹‹å‰çš„æ¶ˆæ¯å°†è¢«å±è”½', { summaryIndex: messageIndex });
    }

    if (role === 'user') {
        GameState.lastUserMessageIndex = messageIndex;
    }

    DebugLog.info('æ¶ˆæ¯ç³»ç»Ÿ', `æ·»åŠ ${role === 'user' ? 'ç”¨æˆ·' : 'AI'}æ¶ˆæ¯`, {
        length: content.length,
        preview: content.substring(0, 100) + '...',
        isSummary: isSummary
    });

    updateLastMessageActions();
}

function updateLastMessageActions() {
    const container = document.getElementById('chatMessages');
    const messages = container.querySelectorAll('.message');

    messages.forEach(msg => {
        const actions = msg.querySelector('.message-actions');
        if (actions) actions.remove();
    });

    if (messages.length > 0) {
        const lastMessage = messages[messages.length - 1];
        const lastIndex = parseInt(lastMessage.dataset.messageIndex);
        const lastHistoryItem = GameState.chatHistory[lastIndex];

        if (lastHistoryItem) {
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';

            if (lastHistoryItem.role === 'assistant') {
                actionsDiv.innerHTML = `
      <button class="message-action-btn edit" onclick="editMessage(${lastIndex})">âœï¸ ç¼–è¾‘</button>
      <button class="message-action-btn regenerate" onclick="regenerateMessage()">ğŸ”„ é‡æ–°ç”Ÿæˆ</button>
    `;
            } else {
                actionsDiv.innerHTML = `
      <button class="message-action-btn edit" onclick="editMessage(${lastIndex})">âœï¸ ç¼–è¾‘</button>
    `;
            }

            lastMessage.appendChild(actionsDiv);
        }
    }
}

function editMessage(index) {
    const container = document.getElementById('chatMessages');
    const messages = container.querySelectorAll('.message');
    let targetMessage = null;

    messages.forEach(msg => {
        if (parseInt(msg.dataset.messageIndex) === index) {
            targetMessage = msg;
        }
    });

    if (!targetMessage) return;

    const historyItem = GameState.chatHistory[index];
    const bubble = targetMessage.querySelector('.message-bubble');
    const originalContent = historyItem.content;

    const actions = targetMessage.querySelector('.message-actions');
    if (actions) actions.style.display = 'none';

    const editContainer = document.createElement('div');
    editContainer.className = 'message-edit-container';
    editContainer.id = `edit-container-${index}`;
    editContainer.innerHTML = `
<textarea class="message-edit-textarea" id="edit-textarea-${index}">${originalContent}</textarea>
<div class="message-edit-actions">
  <button class="message-edit-btn cancel" onclick="cancelEdit(${index})">å–æ¶ˆ</button>
  <button class="message-edit-btn save" onclick="saveEdit(${index})">ä¿å­˜</button>
</div>
      `;

    bubble.style.display = 'none';
    targetMessage.appendChild(editContainer);

    document.getElementById(`edit-textarea-${index}`).focus();

    DebugLog.info('ç¼–è¾‘ç³»ç»Ÿ', 'å¼€å§‹ç¼–è¾‘æ¶ˆæ¯', { index: index });
}

function saveEdit(index) {
    const textarea = document.getElementById(`edit-textarea-${index}`);
    const newContent = textarea.value.trim();

    if (!newContent) {
        showNotification('æ¶ˆæ¯å†…å®¹ä¸èƒ½ä¸ºç©º', 'error');
        return;
    }

    GameState.chatHistory[index].content = newContent;

    const container = document.getElementById('chatMessages');
    const messages = container.querySelectorAll('.message');
    let targetMessage = null;

    messages.forEach(msg => {
        if (parseInt(msg.dataset.messageIndex) === index) {
            targetMessage = msg;
        }
    });

    if (targetMessage) {
        const bubble = targetMessage.querySelector('.message-bubble');
        bubble.innerHTML = formatContent(newContent);
        bubble.style.display = 'block';

        const editContainer = document.getElementById(`edit-container-${index}`);
        if (editContainer) editContainer.remove();

        const actions = targetMessage.querySelector('.message-actions');
        if (actions) actions.style.display = 'flex';
    }

    showNotification('âœ… æ¶ˆæ¯å·²æ›´æ–°', 'success');
    DebugLog.success('ç¼–è¾‘ç³»ç»Ÿ', 'æ¶ˆæ¯ç¼–è¾‘å®Œæˆ', { index: index });
}

function cancelEdit(index) {
    const container = document.getElementById('chatMessages');
    const messages = container.querySelectorAll('.message');
    let targetMessage = null;

    messages.forEach(msg => {
        if (parseInt(msg.dataset.messageIndex) === index) {
            targetMessage = msg;
        }
    });

    if (targetMessage) {
        const bubble = targetMessage.querySelector('.message-bubble');
        bubble.style.display = 'block';

        const editContainer = document.getElementById(`edit-container-${index}`);
        if (editContainer) editContainer.remove();

        const actions = targetMessage.querySelector('.message-actions');
        if (actions) actions.style.display = 'flex';
    }

    DebugLog.info('ç¼–è¾‘ç³»ç»Ÿ', 'å–æ¶ˆç¼–è¾‘', { index: index });
}

async function regenerateMessage() {
    let lastUserIndex = -1;
    for (let i = GameState.chatHistory.length - 1; i >= 0; i--) {
        if (GameState.chatHistory[i].role === 'user') {
            lastUserIndex = i;
            break;
        }
    }

    if (lastUserIndex === -1) {
        showNotification('æ²¡æœ‰æ‰¾åˆ°ç”¨æˆ·æ¶ˆæ¯', 'error');
        return;
    }

    const lastUserMessage = GameState.chatHistory[lastUserIndex].content;

    const lastIndex = GameState.chatHistory.length - 1;
    if (GameState.chatHistory[lastIndex].role === 'assistant') {
        GameState.chatHistory.pop();

        const container = document.getElementById('chatMessages');
        const messages = container.querySelectorAll('.message');
        if (messages.length > 0) {
            messages[messages.length - 1].remove();
        }
    }

    DebugLog.info('é‡æ–°ç”Ÿæˆ', 'å¼€å§‹é‡æ–°ç”ŸæˆAIå“åº”', { userMessage: lastUserMessage.substring(0, 50) + '...' });

    showTypingIndicator();
    document.getElementById('sendBtn').disabled = true;

    await sendToAI(lastUserMessage, true);

    document.getElementById('sendBtn').disabled = false;
}

function formatContent(content) {
    return content
        .replace(/\n/g, '<br>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/ã€Œ(.+?)ã€/g, '<span style="color: var(--accent-cyan);">ã€Œ$1ã€</span>')
        .replace(/ï¼ˆ(.+?)ï¼‰/g, '<span style="color: var(--text-muted); font-style: italic;">ï¼ˆ$1ï¼‰</span>');
}

function showTypingIndicator() {
    const container = document.getElementById('chatMessages');
    const div = document.createElement('div');
    div.className = 'message assistant';
    div.id = 'typingIndicator';
    div.innerHTML = `
<div class="message-sender">ç³»ç»Ÿå™è¿°</div>
<div class="typing-indicator">
  <div class="typing-dot"></div>
  <div class="typing-dot"></div>
  <div class="typing-dot"></div>
</div>
      `;
    container.appendChild(div);
    container.scrollTop = container.scrollHeight;
}

function removeTypingIndicator() {
    const indicator = document.getElementById('typingIndicator');
    if (indicator) indicator.remove();
}

// ==================== æ€»ç»“ç³»ç»Ÿ ====================
function prepareSummary() {
    const defaultSummaryPrompt = `è¯·å¯¹ä¹‹å‰çš„å‰§æƒ…è¿›è¡Œæ€»ç»“ï¼Œè¦æ±‚ï¼š

1. æ¦‚æ‹¬ä¸»è¦å‰§æƒ…å‘å±•å’Œå…³é”®äº‹ä»¶
2. è®°å½•å¥³ä¸»è§’${GameState.heroine.name}çš„çŠ¶æ€å˜åŒ–å’Œå¿ƒç†è½¬å˜
3. æ€»ç»“å·²å®Œæˆçš„ä»»åŠ¡å’Œè·å¾—çš„å¥–åŠ±
4. ä¿ç•™é‡è¦çš„è§’è‰²å…³ç³»å’Œæƒ…æ„Ÿå‘å±•
5. è®°å½•å½“å‰çš„æ¸¸æˆçŠ¶æ€ï¼ˆä½ç½®ã€æ—¶é—´ã€èµ„æºç­‰ï¼‰

è¯·ç”¨500-800å­—è¿›è¡Œæ€»ç»“ï¼Œä¿ç•™å…³é”®ç»†èŠ‚ä»¥ä¾¿åç»­å‰§æƒ…è¡”æ¥ã€‚
æ€»ç»“å®Œæˆåï¼Œåœ¨ç»“å°¾æ·»åŠ ã€æ€»ç»“å®Œæˆã€‘æ ‡è®°ã€‚`;

    const input = document.getElementById('userInput');
    input.value = defaultSummaryPrompt;
    input.style.height = 'auto';
    input.style.height = Math.min(input.scrollHeight, 120) + 'px';
    input.focus();

    showNotification('ğŸ“ æ€»ç»“æç¤ºè¯å·²å¡«å…¥ï¼Œå¯ä»¥ä¿®æ”¹åå‘é€', 'info');
    DebugLog.info('æ€»ç»“ç³»ç»Ÿ', 'å‡†å¤‡æ€»ç»“æç¤ºè¯');
}

// ==================== AIäº¤äº’ ====================
async function sendToAI(userMessage, isRegenerate = false) {
    const systemPrompt = buildSystemPrompt();
    const messages = [
        { role: 'user', content: systemPrompt },
        { role: 'assistant', content: 'æ˜ç™½ï¼Œæˆ‘å°†ä½œä¸ºæœ«ä¸–å¯å–ç”Ÿå­˜æ¸¸æˆçš„å™äº‹ç³»ç»Ÿè¿›è¡Œåˆ›ä½œã€‚' }
    ];

    let effectiveHistory = [];
    if (GameState.summaryIndex >= 0) {
        effectiveHistory = GameState.chatHistory.slice(GameState.summaryIndex);
        DebugLog.info('æ€»ç»“ç³»ç»Ÿ', 'ä½¿ç”¨æ€»ç»“åçš„å†å²è®°å½•', {
            summaryIndex: GameState.summaryIndex,
            effectiveCount: effectiveHistory.length
        });
    } else {
        effectiveHistory = GameState.chatHistory.slice(-8);
    }

    const historyToUse = isRegenerate ? effectiveHistory.slice(0, -1) : effectiveHistory;

    for (const msg of historyToUse) {
        messages.push({ role: msg.role, content: msg.content });
    }

    if (!isRegenerate) {
        messages.push({ role: 'user', content: userMessage });
    }

    const fullPromptForLog = `=== System Prompt ===\n${systemPrompt}\n\n=== å†å²æ¶ˆæ¯ (${historyToUse.length}æ¡) ===\n${historyToUse.map(m => `[${m.role}]: ${m.content.substring(0, 200)}...`).join('\n')}\n\n=== å½“å‰ç”¨æˆ·æ¶ˆæ¯ ===\n${userMessage}`;

    const logId = DebugLog.aiRequest('ä¸»å¯¹è¯', fullPromptForLog, GameState.model);

    try {
        let fullResponse = '';
        await dzmm.completions({
            model: GameState.model,
            messages: messages,
            maxTokens: 2000
        }, (content, done) => {
            fullResponse = content;
            if (done) {
                removeTypingIndicator();
                DebugLog.aiResponse(logId, fullResponse, true);
                processAIResponse(fullResponse, userMessage);
            }
        });
    } catch (error) {
        removeTypingIndicator();
        DebugLog.aiResponse(logId, null, false, error.message);
        DebugLog.error('AIäº¤äº’', 'ä¸»å¯¹è¯APIè¯·æ±‚å¤±è´¥', { error: error.message, userMessage: userMessage });
        addMessage('assistant', `âŒ å‘ç”Ÿé”™è¯¯: ${error.message}`);
    }
}

function buildSystemPrompt() {
    const p = GameState.protagonist;
    const h = GameState.heroine;

    const personalityText = h.personality.map(id => {
        const trait = PersonalityTraits.find(t => t.id === id);
        const desc = h.personalityDesc[id] || trait?.defaultDesc;
        return `${trait?.name}: ${desc}`;
    }).join('\n');

    return `ä½ æ˜¯æœ«ä¸–å¯å–ç”Ÿå­˜æ¸¸æˆçš„å™äº‹AIã€‚

ã€ä¸–ç•Œè§‚ã€‘æå¯’æœ«ä¸–ï¼Œæ–‡æ˜å´©æºƒï¼Œæˆ·å¤–æœ‰è‡´å‘½å¯’æµã€‚

ã€å½“å‰çŠ¶æ€ã€‘æ—¶é—´: ${formatGameTime()} ${GameState.gameTime.weekday}

ã€ä¸»è§’ã€‘${p.name}ï¼Œ${p.age}å²ï¼Œæœ‰æ·«å¦»ç™–å€¾å‘

ã€å¥³ä¸»è§’ã€‘${h.name}ï¼Œ${h.age}å²ï¼Œ${h.identity}ï¼Œä¸»è§’çš„${h.relation}
- æ·«ä¹±ç­‰çº§: ${h.corruptionLevel}æ˜Ÿ
- å‡ºè½¨å€¼: ${h.infidelityValue}%
- å¤„å¥³çŠ¶æ€: ${h.virginStatus}
- æ€§æ ¼ç‰¹ç‚¹:
${personalityText || 'æ— ç‰¹æ®Šè®¾å®š'}

ã€å½“å‰ä»»åŠ¡ã€‘${GameState.currentTasks.daily ? GameState.currentTasks.daily.content : 'æš‚æ— '}

ã€å†™ä½œè¦æ±‚ã€‘
1. æå†™è¯¦ç»†ç”ŸåŠ¨ï¼Œæ„Ÿå®˜ç»†èŠ‚ä¸°å¯Œ
2. å¯¹è¯å£è¯­åŒ–ï¼Œæ€§çˆ±åœºæ™¯ç›´ç™½éœ²éª¨
3. å¥³ä¸»è§’é«˜æ½®æ—¶å«å£°å¤¸å¼ ï¼ˆå“¦é½é½ã€å’¿å’¿å’¿ç­‰ï¼‰
4. å¥³ä¸»è§’ç‹¬è‡ªæ‰§è¡Œä»»åŠ¡ï¼Œä¸»è§’äº«å—éšå¥¸å¿«æ„Ÿ
5. ç»“å°¾ç”¨ã€çŠ¶æ€å˜åŒ–ã€‘æ ‡æ³¨æ•°å€¼å˜åŠ¨`;
}

function processAIResponse(response, userMessage) {
    const changes = parseStateChanges(response);
    if (changes) {
        applyStateChanges(changes);
        DebugLog.info('çŠ¶æ€è§£æ', 'ä»AIå“åº”ä¸­è§£æåˆ°çŠ¶æ€å˜åŒ–', changes);
    }

    const isSummary = response.includes('ã€æ€»ç»“å®Œæˆã€‘') || userMessage.includes('è¯·å¯¹ä¹‹å‰çš„å‰§æƒ…è¿›è¡Œæ€»ç»“');

    addMessage('assistant', response, isSummary);
    updateAllUI();
}

function parseStateChanges(response) {
    const changes = {};
    const coinMatch = response.match(/å¯å–å¸\s*[+ï¼‹]\s*(\d+)/);
    if (coinMatch) changes.coins = parseInt(coinMatch[1]);
    const expMatch = response.match(/ç»éªŒ\s*[+ï¼‹]\s*(\d+)/);
    if (expMatch) changes.exp = parseInt(expMatch[1]);
    const infMatch = response.match(/å‡ºè½¨å€¼\s*[+ï¼‹]\s*(\d+)/);
    if (infMatch) changes.infidelity = parseInt(infMatch[1]);
    return Object.keys(changes).length > 0 ? changes : null;
}

function applyStateChanges(changes) {
    if (changes.coins) {
        GameState.system.coins += changes.coins;
        showNotification(`ğŸ’° +${changes.coins} å¯å–å¸`, 'success');
    }
    if (changes.exp) {
        GameState.system.exp += changes.exp;
        while (GameState.system.exp >= GameState.system.expToNext) {
            GameState.system.exp -= GameState.system.expToNext;
            GameState.system.level++;
            GameState.system.expToNext = Math.floor(GameState.system.expToNext * 1.5);
            showNotification(`ğŸ‰ å‡çº§åˆ° Lv.${GameState.system.level}ï¼`, 'success');
            DebugLog.success('å‡çº§ç³»ç»Ÿ', `ä»AIå“åº”å‡çº§åˆ° Lv.${GameState.system.level}`);
        }
    }
    if (changes.infidelity) {
        GameState.heroine.infidelityValue = Math.min(100, GameState.heroine.infidelityValue + changes.infidelity);
    }
}

// ==================== å•†åº—ç³»ç»Ÿï¼ˆå¸¦ç¼“å­˜ï¼‰ ====================
async function searchShop() {
    const query = document.getElementById('shopSearchInput').value.trim();
    if (!query) {
        showNotification('è¯·è¾“å…¥æœç´¢å†…å®¹', 'error');
        return;
    }

    const resultsContainer = document.getElementById('shopResults');
    const searchBtn = document.getElementById('shopSearchBtn');

    // æ£€æŸ¥ç¼“å­˜ä¸­æ˜¯å¦å·²æœ‰è¯¥æœç´¢ç»“æœ
    if (GameState.shopCache[query]) {
        DebugLog.info('å•†åº—ç³»ç»Ÿ', 'ä»ç¼“å­˜ä¸­åŠ è½½å•†å“', { query: query, count: GameState.shopCache[query].length });
        displayShopItems(GameState.shopCache[query]);
        showNotification('ğŸ“¦ å·²ä»ç¼“å­˜åŠ è½½å•†å“', 'info');
        return;
    }

    searchBtn.disabled = true;
    resultsContainer.innerHTML = `
<div class="shop-loading">
  <div class="shop-loading-spinner"></div>
  æ­£åœ¨æœç´¢å•†å“...
</div>
      `;

    DebugLog.info('å•†åº—ç³»ç»Ÿ', 'å¼€å§‹æœç´¢å•†å“', { query: query });

    const prompt = `ä½ æ˜¯æœ«ä¸–å¯å–ç”Ÿå­˜æ¸¸æˆçš„å•†åº—ç³»ç»Ÿã€‚ç©å®¶æœç´¢: "${query}"

è¯·ç”Ÿæˆ3-4ä¸ªç›¸å…³å•†å“ï¼Œä¸¥æ ¼æŒ‰ç…§JSONæ•°ç»„æ ¼å¼è¿”å›ï¼š
[
  {"name": "å•†å“å", "desc": "æè¿°20-40å­—", "price": ä»·æ ¼10-500, "effect": "æ•ˆæœæè¿°"}
]

å•†å“è¦ç¬¦åˆç°å®(é™¤éç©å®¶æœç´¢è¶…è‡ªç„¶ç‰©å“)ï¼Œåªè¿”å›JSONæ•°ç»„ã€‚`;

    const logId = DebugLog.aiRequest('å•†åº—æœç´¢', prompt, GameState.model);

    try {
        let fullResponse = '';
        await dzmm.completions({
            model: GameState.model,
            messages: [{ role: 'user', content: prompt }],
            maxTokens: 800
        }, (content, done) => {
            fullResponse = content;
            if (done) {
                DebugLog.aiResponse(logId, fullResponse, true);

                try {
                    const jsonMatch = fullResponse.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        const items = JSON.parse(jsonMatch[0]);

                        // ä¿å­˜åˆ°ç¼“å­˜
                        GameState.shopCache[query] = items;

                        // æ·»åŠ åˆ°æœç´¢å†å²ï¼ˆé¿å…é‡å¤ï¼‰
                        if (!GameState.shopSearchHistory.includes(query)) {
                            GameState.shopSearchHistory.unshift(query);
                            // åªä¿ç•™æœ€è¿‘10æ¡æœç´¢å†å²
                            if (GameState.shopSearchHistory.length > 10) {
                                GameState.shopSearchHistory.pop();
                            }
                        }

                        displayShopItems(items);
                        updateShopHistory();
                        DebugLog.success('å•†åº—ç³»ç»Ÿ', 'å•†å“æœç´¢æˆåŠŸå¹¶å·²ç¼“å­˜', { count: items.length, items: items });
                    } else {
                        throw new Error('æ— æ³•ä»å“åº”ä¸­è§£æJSONæ•°ç»„');
                    }
                } catch (e) {
                    DebugLog.error('å•†åº—ç³»ç»Ÿ', 'å•†å“JSONè§£æå¤±è´¥', {
                        error: e.message,
                        response: fullResponse
                    });
                    resultsContainer.innerHTML = `<div class="shop-empty">ç”Ÿæˆå¤±è´¥ï¼Œè¯·é‡è¯•</div>`;
                }
                searchBtn.disabled = false;
            }
        });
    } catch (error) {
        DebugLog.aiResponse(logId, null, false, error.message);
        DebugLog.error('å•†åº—ç³»ç»Ÿ', 'å•†å“æœç´¢APIè¯·æ±‚å¤±è´¥', { error: error.message });
        resultsContainer.innerHTML = `<div class="shop-empty">æœç´¢å¤±è´¥: ${error.message}</div>`;
        searchBtn.disabled = false;
    }
}

// ä»å†å²è®°å½•å¿«é€Ÿæœç´¢
function quickSearchFromHistory(query) {
    document.getElementById('shopSearchInput').value = query;
    searchShop();
}

// æ›´æ–°æœç´¢å†å²æ˜¾ç¤º
function updateShopHistory() {
    const container = document.getElementById('shopHistoryContainer');
    const tagsContainer = document.getElementById('shopHistoryTags');

    if (GameState.shopSearchHistory.length === 0) {
        container.style.display = 'none';
        return;
    }

    container.style.display = 'block';
    tagsContainer.innerHTML = GameState.shopSearchHistory.map(query => `
<span class="shop-history-tag" onclick="quickSearchFromHistory('${query}')">${query}</span>
      `).join('');
}

function displayShopItems(items) {
    const container = document.getElementById('shopResults');
    const coins = GameState.system.coins;

    container.innerHTML = items.map((item, i) => `
<div class="shop-item" id="shop-item-${i}">
  <div class="shop-item-header">
    <div class="shop-item-name">${item.name}</div>
    <div class="shop-item-price">ğŸ’° ${item.price}</div>
  </div>
  <div class="shop-item-desc">${item.desc}</div>
  <div class="shop-item-effect">âœ¨ ${item.effect}</div>
  <button class="shop-item-btn" onclick="buyItem(${i}, '${encodeURIComponent(JSON.stringify(item))}')"
          ${coins < item.price ? 'disabled' : ''}>
    ${coins < item.price ? 'ä½™é¢ä¸è¶³' : 'è´­ä¹°'}
  </button>
</div>
      `).join('');
}

function buyItem(index, encodedItem) {
    const item = JSON.parse(decodeURIComponent(encodedItem));
    if (GameState.system.coins < item.price) {
        showNotification('å¯å–å¸ä¸è¶³ï¼', 'error');
        DebugLog.warning('å•†åº—ç³»ç»Ÿ', 'è´­ä¹°å¤±è´¥ï¼šä½™é¢ä¸è¶³', { item: item.name, price: item.price, coins: GameState.system.coins });
        return;
    }

    GameState.system.coins -= item.price;

    if (item.effect.includes('èƒ½åŠ›') || item.effect.includes('æ°¸ä¹…') || item.effect.includes('æå‡')) {
        GameState.abilities.push({ name: item.name, desc: item.effect });
        DebugLog.info('å•†åº—ç³»ç»Ÿ', 'è·å¾—æ–°èƒ½åŠ›', { name: item.name, effect: item.effect });
    } else {
        GameState.shelter.items.push(item.name);
        DebugLog.info('å•†åº—ç³»ç»Ÿ', 'è·å¾—æ–°ç‰©å“', { name: item.name });
    }

    GameState.purchaseHistory.push({ name: item.name, price: item.price });
    updateAllUI();

    const btn = document.querySelector(`#shop-item-${index} .shop-item-btn`);
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'âœ… å·²è´­ä¹°';
    }

    showNotification(`âœ… è´­ä¹°æˆåŠŸ: ${item.name}`, 'success');
    DebugLog.success('å•†åº—ç³»ç»Ÿ', 'è´­ä¹°æˆåŠŸ', { item: item.name, price: item.price });
}

function openShop() {
    document.getElementById('shopModal').classList.add('active');
    document.getElementById('shopCoins').textContent = `${GameState.system.coins} ğŸ’°`;
    document.getElementById('shopSearchInput').value = '';
    document.getElementById('shopResults').innerHTML = `<div class="shop-empty">ğŸ›ï¸ è¾“å…¥å…³é”®è¯æœç´¢å•†å“</div>`;
    updateShopHistory();
    DebugLog.info('å•†åº—ç³»ç»Ÿ', 'æ‰“å¼€å•†åº—');
}

function closeShop() {
    document.getElementById('shopModal').classList.remove('active');
}

// ==================== å­˜æ¡£ç³»ç»Ÿ ====================
function openSaveModal() {
    document.getElementById('saveModal').classList.add('active');
    renderSaveSlots();
    DebugLog.info('å­˜æ¡£ç³»ç»Ÿ', 'æ‰“å¼€å­˜æ¡£ç®¡ç†');
}

function closeSaveModal() {
    document.getElementById('saveModal').classList.remove('active');
}

function renderSaveSlots() {
    const container = document.getElementById('saveSlots');

    for (let i = 0; i < 3; i++) {
        const saved = localStorage.getItem(`ntrGame_slot_${i}`);
        if (saved) {
            try {
                GameState.saves[i] = JSON.parse(saved);
            } catch (e) {
                GameState.saves[i] = null;
                DebugLog.error('å­˜æ¡£ç³»ç»Ÿ', `å­˜æ¡£æ§½ä½${i}è¯»å–å¤±è´¥`, { error: e.message });
            }
        }
    }

    container.innerHTML = GameState.saves.map((save, i) => {
        if (save) {
            return `
    <div class="save-slot">
      <div class="save-slot-header">
        <div class="save-slot-name">å­˜æ¡£ ${i + 1}</div>
        <div class="save-slot-time">${save.savedAt || 'æœªçŸ¥æ—¶é—´'}</div>
      </div>
      <div class="save-slot-info">
        ${save.protagonist?.name || 'æœªçŸ¥'} & ${save.heroine?.name || 'æœªçŸ¥'}<br>
        Lv.${save.system?.level || 1} | ğŸ’°${save.system?.coins || 0} | â­${save.heroine?.corruptionLevel || 1}
      </div>
      <div class="save-slot-actions">
        <button class="save-slot-btn save" onclick="saveToSlot(${i})">è¦†ç›–</button>
        <button class="save-slot-btn load" onclick="loadFromSlot(${i})">è¯»å–</button>
        <button class="save-slot-btn delete" onclick="deleteSlot(${i})">åˆ é™¤</button>
      </div>
    </div>
  `;
        } else {
            return `
    <div class="save-slot">
      <div class="save-slot-header">
        <div class="save-slot-name">å­˜æ¡£ ${i + 1}</div>
      </div>
      <div class="save-slot-info save-slot-empty">ç©ºå­˜æ¡£</div>
      <div class="save-slot-actions">
        <button class="save-slot-btn save" onclick="saveToSlot(${i})">ä¿å­˜</button>
        <button class="save-slot-btn load" disabled>è¯»å–</button>
        <button class="save-slot-btn delete" disabled>åˆ é™¤</button>
      </div>
    </div>
  `;
        }
    }).join('');
}

function saveToSlot(slot) {
    try {
        const saveData = JSON.parse(JSON.stringify(GameState));
        saveData.savedAt = formatGameTime();
        saveData.saves = undefined;

        localStorage.setItem(`ntrGame_slot_${slot}`, JSON.stringify(saveData));
        GameState.saves[slot] = saveData;

        renderSaveSlots();
        showNotification(`âœ… å·²ä¿å­˜åˆ°å­˜æ¡£ ${slot + 1}`, 'success');
        DebugLog.success('å­˜æ¡£ç³»ç»Ÿ', `ä¿å­˜åˆ°å­˜æ¡£æ§½ä½ ${slot + 1}`, { savedAt: saveData.savedAt });
    } catch (e) {
        DebugLog.error('å­˜æ¡£ç³»ç»Ÿ', `ä¿å­˜åˆ°å­˜æ¡£æ§½ä½${slot + 1}å¤±è´¥`, { error: e.message });
        showNotification('âŒ ä¿å­˜å¤±è´¥', 'error');
    }
}

function loadFromSlot(slot) {
    const saved = localStorage.getItem(`ntrGame_slot_${slot}`);
    if (!saved) {
        showNotification('å­˜æ¡£ä¸å­˜åœ¨', 'error');
        DebugLog.warning('å­˜æ¡£ç³»ç»Ÿ', `å­˜æ¡£æ§½ä½${slot + 1}ä¸å­˜åœ¨`);
        return;
    }

    try {
        const saveData = JSON.parse(saved);
        const currentSaves = GameState.saves;

        Object.assign(GameState, saveData);
        GameState.saves = currentSaves;

        // ç¡®ä¿æ–°å¢çš„å­—æ®µæœ‰é»˜è®¤å€¼
        if (!GameState.shopCache) GameState.shopCache = {};
        if (!GameState.shopSearchHistory) GameState.shopSearchHistory = [];

        renderChatHistory();

        updateAllUI();
        closeSaveModal();
        showNotification(`âœ… å·²åŠ è½½å­˜æ¡£ ${slot + 1}`, 'success');
        DebugLog.success('å­˜æ¡£ç³»ç»Ÿ', `åŠ è½½å­˜æ¡£æ§½ä½ ${slot + 1}`, { savedAt: saveData.savedAt });
    } catch (e) {
        DebugLog.error('å­˜æ¡£ç³»ç»Ÿ', `åŠ è½½å­˜æ¡£æ§½ä½${slot + 1}å¤±è´¥`, { error: e.message });
        showNotification('å­˜æ¡£æŸå', 'error');
    }
}

function renderChatHistory() {
    const container = document.getElementById('chatMessages');
    container.innerHTML = '';

    GameState.chatHistory.forEach((msg, index) => {
        const div = document.createElement('div');
        div.className = `message ${msg.role}${msg.isSummary ? ' summary' : ''}`;
        div.dataset.messageIndex = index;

        const sender = msg.role === 'user' ? GameState.protagonist.name : 'ç³»ç»Ÿå™è¿°';
        const summaryBadge = msg.isSummary ? '<span class="summary-badge">ğŸ“ å‰§æƒ…æ€»ç»“</span>' : '';

        div.innerHTML = `
  <div class="message-sender">${sender}${summaryBadge}</div>
  <div class="message-bubble">${formatContent(msg.content)}</div>
`;

        container.appendChild(div);
    });

    container.scrollTop = container.scrollHeight;
    updateLastMessageActions();
}

function deleteSlot(slot) {
    if (!confirm(`ç¡®å®šè¦åˆ é™¤å­˜æ¡£ ${slot + 1} å—ï¼Ÿ`)) return;

    localStorage.removeItem(`ntrGame_slot_${slot}`);
    GameState.saves[slot] = null;

    renderSaveSlots();
    showNotification(`ğŸ—‘ï¸ å·²åˆ é™¤å­˜æ¡£ ${slot + 1}`, 'info');
    DebugLog.info('å­˜æ¡£ç³»ç»Ÿ', `åˆ é™¤å­˜æ¡£æ§½ä½ ${slot + 1}`);
}

// ==================== æ¨¡å‹è®¾ç½® ====================
function openModelModal() {
    document.getElementById('modelModal').classList.add('active');
    document.getElementById('inGameModelSelect').value = GameState.model;
    document.getElementById('currentModelDisplay').textContent = GameState.model;
}

function closeModelModal() {
    document.getElementById('modelModal').classList.remove('active');
}

function applyModel() {
    const oldModel = GameState.model;
    GameState.model = document.getElementById('inGameModelSelect').value;
    document.getElementById('currentModelDisplay').textContent = GameState.model;
    closeModelModal();
    showNotification(`âœ… å·²åˆ‡æ¢åˆ°: ${GameState.model}`, 'success');
    DebugLog.info('æ¨¡å‹è®¾ç½®', `åˆ‡æ¢æ¨¡å‹: ${oldModel} -> ${GameState.model}`);
}

// ==================== ç”¨æˆ·äº¤äº’ ====================
async function sendMessage() {
    const input = document.getElementById('userInput');
    const message = input.value.trim();
    if (!message) return;

    input.value = '';
    input.style.height = 'auto';

    addMessage('user', message);
    showTypingIndicator();
    document.getElementById('sendBtn').disabled = true;

    await sendToAI(message);

    document.getElementById('sendBtn').disabled = false;
}

function quickAction(action) {
    document.getElementById('userInput').value = action;
    sendMessage();
    DebugLog.info('å¿«æ·æ“ä½œ', `æ‰§è¡Œå¿«æ·æ“ä½œ: ${action}`);
}

// ==================== æ¸¸æˆå¯åŠ¨ ====================
async function startGame() {
    DebugLog.info('æ¸¸æˆå¯åŠ¨', 'å¼€å§‹åˆå§‹åŒ–æ¸¸æˆ...');

    GameState.model = document.getElementById('modelSelect').value;
    GameState.protagonist.name = document.getElementById('protagonistName').value || 'é™ˆé»˜';
    let pAge = parseInt(document.getElementById('protagonistAge').value) || 22;
    GameState.protagonist.age = Math.max(18, pAge);
    GameState.heroine.name = document.getElementById('heroineName').value || 'æ—é›¨æ™´';
    let hAge = parseInt(document.getElementById('heroineAge').value) || 21;
    GameState.heroine.age = Math.max(18, hAge);
    GameState.heroine.relation = document.getElementById('heroineRelation').value || 'å¥³å‹';
    GameState.heroine.identity = document.getElementById('heroineIdentity').value || 'å¤§å­¦æ ¡èŠ±';

    const virginSelect = document.getElementById('virginSelect').value;
    if (virginSelect === 'yes') {
        GameState.heroine.virginStatus = 'å®Œç’§';
    } else {
        const selectedOption = document.querySelector('.radio-option.selected input');
        if (selectedOption) {
            const value = selectedOption.value;
            if (value === 'protagonist') {
                GameState.heroine.virginStatus = `è¢«${GameState.protagonist.name}å¤ºèµ°`;
            } else if (value === 'other') {
                GameState.heroine.virginStatus = 'è¢«å…¶ä»–äººå¤ºèµ°';
            } else if (value === 'custom') {
                GameState.heroine.virginStatus = document.getElementById('customVirginText').value || 'è¢«å…¶ä»–äººå¤ºèµ°';
            }
        } else {
            GameState.heroine.virginStatus = 'è¢«å…¶ä»–äººå¤ºèµ°';
        }
    }

    const selectedTags = document.querySelectorAll('.personality-tag.selected');
    GameState.heroine.personality = Array.from(selectedTags).map(tag => tag.dataset.id);

    DebugLog.success('æ¸¸æˆå¯åŠ¨', 'è§’è‰²è®¾ç½®å®Œæˆ', {
        protagonist: GameState.protagonist,
        heroine: {
            name: GameState.heroine.name,
            age: GameState.heroine.age,
            relation: GameState.heroine.relation,
            identity: GameState.heroine.identity,
            personality: GameState.heroine.personality,
            virginStatus: GameState.heroine.virginStatus
        },
        model: GameState.model
    });

    document.getElementById('startScreen').style.display = 'none';
    document.getElementById('gameScreen').style.display = 'block';

    updateAllUI();

    DebugLog.info('æ¸¸æˆå¯åŠ¨', 'å¼€å§‹ç”Ÿæˆåˆå§‹ä»»åŠ¡...');
    await generateDailyTask();

    showTypingIndicator();

    const personalityText = GameState.heroine.personality.map(id => {
        const trait = PersonalityTraits.find(t => t.id === id);
        return trait?.name;
    }).filter(Boolean).join('ã€') || 'æ™®é€š';

    const openingPrompt = `æ¸¸æˆå¼€å§‹ã€‚ç”Ÿæˆå¼€åœºå‰§æƒ…ï¼š

ä¸»è§’${GameState.protagonist.name}ï¼ˆ${GameState.protagonist.age}å²ï¼‰åœ¨æœ«æ—¥å¯’æµåï¼Œä¸${GameState.heroine.relation}${GameState.heroine.name}ï¼ˆ${GameState.heroine.age}å²ï¼Œ${GameState.heroine.identity}ï¼Œæ€§æ ¼ï¼š${personalityText}ï¼‰èº²åœ¨é¿éš¾æ‰€å†…ã€‚

å¥³ä¸»è§’å¤„å¥³çŠ¶æ€ï¼š${GameState.heroine.virginStatus}

æå†™ï¼š
1. é¿éš¾æ‰€ç¯å¢ƒ
2. ä¸¤äººçš„äº²å¯†äº’åŠ¨ï¼ˆä½“ç°å¥³ä¸»è§’çš„æ€§æ ¼ç‰¹ç‚¹ï¼‰
3. ç³»ç»Ÿé¦–æ¬¡æ¿€æ´»
4. æé†’ç”¨æˆ·æŸ¥çœ‹ä¾§è¾¹æ çš„ä»»åŠ¡

å™äº‹ç»†è…»ï¼Œå¯¹è¯ç”ŸåŠ¨ã€‚`;

    DebugLog.info('æ¸¸æˆå¯åŠ¨', 'å¼€å§‹ç”Ÿæˆå¼€åœºå‰§æƒ…...');
    await sendToAI(openingPrompt);
    DebugLog.success('æ¸¸æˆå¯åŠ¨', 'æ¸¸æˆåˆå§‹åŒ–å®Œæˆ');
}

// ==================== äº‹ä»¶ç›‘å¬ ====================
document.getElementById('userInput').addEventListener('keydown', function (e) {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
    }
});

document.getElementById('userInput').addEventListener('input', function () {
    this.style.height = 'auto';
    this.style.height = Math.min(this.scrollHeight, 120) + 'px';
});

document.querySelectorAll('.modal-overlay').forEach(overlay => {
    overlay.addEventListener('click', function (e) {
        if (e.target === this) this.classList.remove('active');
    });
});

// ==================== åˆå§‹åŒ– ====================
initPersonalityTags();
DebugLog.info('ç³»ç»Ÿåˆå§‹åŒ–', 'é¡µé¢åŠ è½½å®Œæˆï¼Œç­‰å¾…ç”¨æˆ·å¼€å§‹æ¸¸æˆ');

function handleResize() {
    const panel = document.getElementById('sidePanel');
    const chat = document.getElementById('chatContainer');
    const overlay = document.getElementById('mobileOverlay');
    const btn = document.getElementById('togglePanelBtn');

    if (isMobile()) {
        panel.classList.remove('collapsed');
        chat.classList.remove('expanded');
        if (!panel.classList.contains('mobile-visible')) {
            overlay.classList.remove('active');
            btn.classList.remove('active');
        }
    } else {
        panel.classList.remove('mobile-visible');
        overlay.classList.remove('active');
        btn.classList.remove('active');
        panel.classList.remove('collapsed');
        chat.classList.remove('expanded');
    }
}

window.addEventListener('resize', handleResize);
handleResize();

if (typeof dzmm === 'undefined') {
    DebugLog.error('ç³»ç»Ÿåˆå§‹åŒ–', 'dzmmå¯¹è±¡æœªå®šä¹‰ï¼ŒAIåŠŸèƒ½å°†æ— æ³•ä½¿ç”¨', {
        hint: 'è¯·ç¡®ä¿åœ¨æ”¯æŒdzmmçš„ç¯å¢ƒä¸­è¿è¡Œ'
    });
} else {
    DebugLog.success('ç³»ç»Ÿåˆå§‹åŒ–', 'dzmmå¯¹è±¡å·²å°±ç»ª');
}